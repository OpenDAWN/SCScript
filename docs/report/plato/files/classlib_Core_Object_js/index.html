<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - classlib/Core/Object.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>classlib/Core/Object.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">127.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">930</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">70.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.24</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">SCScript.install(function(sc) {
  &quot;use strict&quot;;

  var $ = sc.lang.$;
  var $nil   = $.nil;
  var $true  = $.true;
  var $false = $.false;
  var $int0  = $.int0;
  var $int1  = $.int1;
  var strlib = sc.libs.strlib;

  var SCArray = $(&quot;Array&quot;);
  var SCRoutine = $(&quot;Routine&quot;);
  var SCAssociation = $(&quot;Association&quot;);

  sc.lang.klass.refine(&quot;Object&quot;, function(builder, _) {
    builder.addMethod(&quot;valueOf&quot;, function() {
      return this._;
    });

    builder.addMethod(&quot;toString&quot;, function() {
      return String(sc.libs.strlib.article(this.__className) + &quot; &quot; + this.__className);
    });

    builder.addMethod(&quot;toJSON&quot;, function() {
      return JSON.stringify({ class: this.__className, hash: this.__hash });
    });

    builder.addMethod(&quot;__num__&quot;, function() {
      throw new Error(strlib.format(&quot;#{0} cannot be converted to a Number.&quot;, this.__className));
    });

    builder.addMethod(&quot;__int__&quot;, function() {
      return this.__num__()|0;
    });

    builder.addMethod(&quot;__bool__&quot;, function() {
      throw new Error(strlib.format(&quot;#{0} cannot be converted to a Boolean.&quot;, this.__className));
    });

    builder.addMethod(&quot;__sym__&quot;, function() {
      throw new Error(strlib.format(&quot;#{0} cannot be converted to a Symbol.&quot;, this.__className));
    });

    builder.addMethod(&quot;__str__&quot;, function() {
      return String(this);
    });

    // TODO: implements $new
    // TODO: implements $newCopyArgs

    builder.doesNotUnderstand(&quot;newFrom&quot;);

    // TODO: implements dump

    builder.addMethod(&quot;post&quot;, function() {
      this.asString().post();
      return this;
    });

    builder.addMethod(&quot;postln&quot;, function() {
      this.asString().postln();
      return this;
    });

    builder.addMethod(&quot;postc&quot;, function() {
      this.asString().postc();
      return this;
    });

    builder.addMethod(&quot;postcln&quot;, function() {
      this.asString().postcln();
      return this;
    });

    // TODO: implements postcs
    // TODO: implements totalFree
    // TODO: implements largestFreeBlock
    // TODO: implements gcDumpGrey
    // TODO: implements gcDumpSet
    // TODO: implements gcInfo
    // TODO: implements gcSanity
    // TODO: implements canCallOS

    builder.addMethod(&quot;size&quot;, function() {
      return $int0;
    });

    builder.addMethod(&quot;indexedSize&quot;, function() {
      return $int0;
    });

    builder.addMethod(&quot;flatSize&quot;, function() {
      return $int1;
    });

    builder.addMethod(&quot;do&quot;, function($function) {
      sc.lang.iterator.execute(
        sc.lang.iterator.object$do(this),
        $function
      );
      return this;
    });

    builder.addMethod(&quot;generate&quot;, {
      args: &quot;function; state&quot;
    }, function($function, $state) {
      this.do($function);
      return $state;
    });

    builder.addMethod(&quot;class&quot;, function() {
      return this.__class;
    });

    builder.addMethod(&quot;isKindOf&quot;, function($aClass) {
      return $.Boolean(this instanceof $aClass.__Spec);
    });

    builder.addMethod(&quot;isMemberOf&quot;, function($aClass) {
      return $.Boolean(this.__class === $aClass);
    });

    function sym2str($aSymbol) {
      return $aSymbol ? $aSymbol.__sym__() : /* istanbul ignore next */ &quot;&quot;;
    }

    function getFunction($this, methodName) {
      if (/^([a-z]\w*|[-+*\/%&lt;=&gt;!?&amp;|@]+)$/.test(methodName)) {
        if (typeof $this[methodName] === &quot;function&quot;) {
          return $this[methodName];
        }
      }
      return null;
    }

    function respondsTo($this, $aSymbol) {
      var func = getFunction($this, sym2str($aSymbol));
      return func &amp;&amp; !func.__errorType;
    }

    builder.addMethod(&quot;respondsTo&quot;, function($aSymbol) {
      var $this = this;
      if ($aSymbol &amp;&amp; $aSymbol.isSequenceableCollection().__bool__()) {
        return $.Boolean($aSymbol.asArray()._.every(function($aSymbol) {
          return $.Boolean(respondsTo($this, $aSymbol)).__bool__();
        }));
      }
      return $.Boolean(respondsTo(this, $aSymbol));
    });

    function performMsg($this, msg) {
      var methodName = sym2str(msg[0]);
      var func = getFunction($this, methodName);

      if (func) {
        return func.apply($this, msg.slice(1));
      }

      throw new Error(strlib.format(&quot;Message &#039;#{0}&#039; is not understood.&quot;, methodName));
    }

    builder.addMethod(&quot;performMsg&quot;, function($msg) {
      return performMsg(this, $msg ? $msg.asArray()._ : /* istanbul ignore next */ []);
    });

    builder.addMethod(&quot;perform&quot;, function() {
      return performMsg(this, _.toArray(arguments));
    });

    builder.addMethod(&quot;performList&quot;, function($selector, $arglist) {
      return performMsg(this, [ $selector ].concat(
        $arglist ? $arglist.asArray()._ : /* istanbul ignore next */ []
      ));
    });

    builder.addMethod(&quot;functionPerformList&quot;);

    // TODO: implements superPerform
    // TODO: implements superPerformList

    builder.addMethod(&quot;tryPerform&quot;, function($selector) {
      if (respondsTo(this, $selector)) {
        return performMsg(this, _.toArray(arguments));
      }
      return $nil;
    });

    builder.addMethod(&quot;multiChannelPerform&quot;, function($selector) {
      var list, items, length, i, args, $obj, iter;
      items = [ this ].concat(_.toArray(arguments).slice(1));
      length = Math.max.apply(null, items.map(function($_) {
        return $_.size().__int__();
      }));
      iter = function($_) {
        return $_.wrapAt ? $_.wrapAt($.Integer(i)) : $_;
      };
      list = new Array(length);
      for (i = 0; i &lt; length; ++i) {
        args = items.map(iter);
        $obj = args[0];
        args[0] = $selector;
        list[i] = performMsg($obj, args);
      }
      return $.Array(list);
    });

    // TODO: implements performWithEnvir
    // TODO: implements performKeyValuePairs

    var copy = function(obj) {
      var copied = obj;

      if (Array.isArray(obj)) {
        copied = obj.slice();
      } else if (obj &amp;&amp; obj.constructor === Object) {
        copied = {};
        Object.keys(obj).forEach(function(key) {
          copied[key] = obj[key];
        });
      }

      return copied;
    };

    builder.addMethod(&quot;copy&quot;, function() {
      return this.shallowCopy();
    });

    // TODO: implements contentsCopy

    builder.addMethod(&quot;shallowCopy&quot;, function() {
      var a = new this.__Spec([]);

      Object.keys(this).forEach(function(key) {
        a[key] = copy(this[key]);
      }, this);

      if (this._ === this) {
        a._ = a;
      }

      return a;
    });

    // TODO: implements copyImmutable
    // TODO: implements deepCopy

    builder.addMethod(&quot;dup&quot;, {
      args: &quot;n=2&quot;
    }, function($n) {
      var $this = this;
      var array, i, n;

      if ($n.isSequenceableCollection().__bool__()) {
        return SCArray.fillND($n, $.Func(function() {
          return $this.copy();
        }));
      }

      n = $n.__int__();
      array = new Array(n);
      for (i = 0; i &lt; n; ++i) {
        array[i] = this.copy();
      }

      return $.Array(array);
    });

    builder.addMethod(&quot;!&quot;, function($n) {
      return this.dup($n);
    });

    builder.addMethod(&quot;poll&quot;, function() {
      return this.value();
    });

    builder.addMethod(&quot;value&quot;);
    builder.addMethod(&quot;valueArray&quot;);
    builder.addMethod(&quot;valueEnvir&quot;);
    builder.addMethod(&quot;valueArrayEnvir&quot;);

    builder.addMethod(&quot;==&quot;, function($obj) {
      return this [&quot;===&quot;] ($obj);
    });

    builder.addMethod(&quot;!=&quot;, function($obj) {
      return (this [&quot;==&quot;] ($obj)).not();
    });

    builder.addMethod(&quot;===&quot;, function($obj) {
      return $.Boolean(this === $obj);
    });

    builder.addMethod(&quot;!==&quot;, function($obj) {
      return $.Boolean(this !== $obj);
    });

    builder.addMethod(&quot;equals&quot;, {
      args: &quot;that; properties&quot;
    }, function($that, $properties) {
      var $this = this;
      if (this === $that) {
        return $true;
      }
      if (this.respondsTo($properties).__bool__() &amp;&amp; $that.respondsTo($properties).__bool__()) {
        return $.Boolean($properties.asArray()._.every(function($_) {
          return performMsg($this, [ $_ ]) [&quot;==&quot;] (performMsg($that, [ $_ ])).__bool__();
        }));
      }
      return this [&quot;==&quot;] ($that);
    });

    // TODO: implements compareObject
    // TODO: implements instVarHash

    builder.addMethod(&quot;basicHash&quot;, function() {
      return $.Integer(this.__hash);
    });

    builder.addMethod(&quot;hash&quot;, function() {
      return $.Integer(this.__hash);
    });

    builder.addMethod(&quot;identityHash&quot;, function() {
      return $.Integer(this.__hash);
    });

    builder.addMethod(&quot;-&gt;&quot;, function($obj) {
      return SCAssociation.new(this, $obj);
    });

    builder.addMethod(&quot;next&quot;);
    builder.addMethod(&quot;reset&quot;);

    builder.addMethod(&quot;first&quot;, {
      args: &quot;inval&quot;
    }, function($inval) {
      this.reset();
      return this.next($inval);
    });

    builder.addMethod(&quot;iter&quot;, function() {
      return $(&quot;OneShotStream&quot;).new(this);
    });

    builder.addMethod(&quot;stop&quot;);
    builder.addMethod(&quot;free&quot;);
    builder.addMethod(&quot;clear&quot;);
    builder.addMethod(&quot;removedFromScheduler&quot;);
    builder.addMethod(&quot;isPlaying&quot;, sc.FALSE);

    builder.addMethod(&quot;embedInStream&quot;, function() {
      return this.yield();
    });

    builder.addMethod(&quot;cyc&quot;, {
      args: &quot;n=inf&quot;
    }, function($n) {
      var $this = this;
      return SCRoutine.new($.Function(function() {
        var $inval;
        return [
          function(_arg0) {
            $inval = _arg0;
            return $n.do($.Function(function() {
              return [
                function() {
                  $inval = $this.embedInStream($inval);
                  return $inval;
                },
                function() {
                  return $this.reset();
                },
                $.NOP
              ];
            }));
          },
          function() {
            $inval = null;
          }
        ];
      }));
    });

    builder.addMethod(&quot;fin&quot;, {
      args: &quot;n=1&quot;
    }, function($n) {
      var $this = this;
      return SCRoutine.new($.Function(function() {
        var $inval;
        return [
          function(_arg0) {
            var $item;
            $inval = _arg0;
            return $n.do($.Function(function() {
              return [
                function() {
                  $item = $this.next($inval);
                  return $item;
                },
                function() {
                  if ($item === $nil) {
                    $nil.alwaysYield();
                  }
                  return $nil;
                },
                function() {
                  $inval = $item.yield();
                  return $inval;
                },
                $.NOP
              ];
            }));
          },
          function() {
            $inval = null;
          }
        ];
      }));
    });

    builder.addMethod(&quot;repeat&quot;, {
      args: &quot;repeats=inf&quot;
    }, function($repeats) {
      return $(&quot;Pn&quot;).new(this, $repeats).asStream();
    });

    builder.addMethod(&quot;loop&quot;, function() {
      return this.repeat($.Float(Infinity));
    });

    builder.addMethod(&quot;asStream&quot;);

    builder.addMethod(&quot;streamArg&quot;, {
      args: &quot;embed=false&quot;
    }, function($embed) {
      var $this = this;
      if ($embed === $true) {
        return SCRoutine.new($.Function(function() {
          var $inval;
          return [
            function(_arg) {
              $inval = _arg;
              return $this.embedInStream($inval);
            },
            function() {
              $inval = null;
            }
          ];
        }));
      } else {
        return SCRoutine.new($.Func(function() {
          return $.Func(function() {
            return $this.yield();
          }).loop();
        }));
      }
    });

    builder.addMethod(&quot;eventAt&quot;, function() {
      return $nil;
    });

    builder.addMethod(&quot;composeEvents&quot;, {
      args: &quot;event&quot;
    }, function($event) {
      return $event.copy();
    });

    builder.addMethod(&quot;finishEvent&quot;);
    builder.addMethod(&quot;atLimit&quot;, sc.FALSE);
    builder.addMethod(&quot;isRest&quot;, sc.FALSE);
    builder.addMethod(&quot;threadPlayer&quot;);
    builder.addMethod(&quot;threadPlayer_&quot;);
    builder.addMethod(&quot;?&quot;);
    builder.addMethod(&quot;??&quot;);

    builder.addMethod(&quot;!?&quot;, function($obj) {
      return $obj.value(this);
    });

    builder.addMethod(&quot;isNil&quot;, sc.FALSE);
    builder.addMethod(&quot;notNil&quot;, sc.TRUE);
    builder.addMethod(&quot;isNumber&quot;, sc.FALSE);
    builder.addMethod(&quot;isInteger&quot;, sc.FALSE);
    builder.addMethod(&quot;isFloat&quot;, sc.FALSE);
    builder.addMethod(&quot;isSequenceableCollection&quot;, sc.FALSE);
    builder.addMethod(&quot;isCollection&quot;, sc.FALSE);
    builder.addMethod(&quot;isArray&quot;, sc.FALSE);
    builder.addMethod(&quot;isString&quot;, sc.FALSE);
    builder.addMethod(&quot;containsSeqColl&quot;, sc.FALSE);
    builder.addMethod(&quot;isValidUGenInput&quot;, sc.FALSE);
    builder.addMethod(&quot;isException&quot;, sc.FALSE);
    builder.addMethod(&quot;isFunction&quot;, sc.FALSE);

    builder.addMethod(&quot;matchItem&quot;, {
      args: &quot;item&quot;
    }, function($item) {
      return this [&quot;===&quot;] ($item);
    });

    builder.addMethod(&quot;trueAt&quot;, sc.FALSE);

    builder.addMethod(&quot;falseAt&quot;, {
      args: &quot;key&quot;
    }, function($key) {
      return this.trueAt($key).not();
    });

    // TODO: implements pointsTo
    // TODO: implements mutable
    // TODO: implements frozen
    // TODO: implements halt
    // TODO: implements primitiveFailed
    // TODO: implements reportError
    // TODO: implements subclassResponsibility
    // TODO: implements doesNotUnderstand
    // TODO: implements shouldNotImplement
    // TODO: implements outOfContextReturn
    // TODO: implements immutableError
    // TODO: implements deprecated
    // TODO: implements mustBeBoolean
    // TODO: implements notYetImplemented
    // TODO: implements dumpBackTrace
    // TODO: implements getBackTrace
    // TODO: implements throw

    builder.addMethod(&quot;species&quot;, function() {
      return this.class();
    });

    builder.addMethod(&quot;asCollection&quot;, function() {
      return $.Array([ this ]);
    });

    builder.addMethod(&quot;asSymbol&quot;, function() {
      return this.asString().asSymbol();
    });

    builder.addMethod(&quot;asString&quot;, function() {
      return $.String(String(this));
    });

    // TODO: implements asCompileString
    // TODO: implements cs
    // TODO: implements printClassNameOn
    // TODO: implements printOn
    // TODO: implements storeOn
    // TODO: implements storeParamsOn
    // TODO: implements simplifyStoreArgs
    // TODO: implements storeArgs
    // TODO: implements storeModifiersOn

    builder.addMethod(&quot;as&quot;, {
      args: &quot;aSimilarClass&quot;
    }, function($aSimilarClass) {
      return $aSimilarClass.newFrom(this);
    });

    builder.addMethod(&quot;dereference&quot;);

    builder.addMethod(&quot;reference&quot;, function() {
      return $.Ref(this);
    });

    builder.addMethod(&quot;asRef&quot;, function() {
      return $.Ref(this);
    });

    builder.addMethod(&quot;asArray&quot;, function() {
      return this.asCollection().asArray();
    });

    builder.addMethod(&quot;asSequenceableCollection&quot;, function() {
      return this.asArray();
    });

    builder.addMethod(&quot;rank&quot;, function() {
      return $int0;
    });

    builder.addMethod(&quot;deepCollect&quot;, {
      args: &quot;depth; function; index; rank&quot;
    }, function($depth, $function, $index, $rank) {
      return $function.value(this, $index, $rank);
    });

    builder.addMethod(&quot;deepDo&quot;, {
      args: &quot;depth; function; index; rank&quot;
    }, function($depth, $function, $index, $rank) {
      $function.value(this, $index, $rank);
      return this;
    });

    builder.addMethod(&quot;slice&quot;);

    builder.addMethod(&quot;shape&quot;, function() {
      return $nil;
    });

    builder.addMethod(&quot;unbubble&quot;);

    builder.addMethod(&quot;bubble&quot;, {
      args: &quot;depth; levels&quot;
    }, function($depth, $levels) {
      var levels, a;

      levels = $levels.__int__();
      if (levels &lt;= 1) {
        a = [ this ];
      } else {
        a = [
          this.bubble($depth, $.Integer(levels - 1))
        ];
      }

      return $.Array(a);
    });

    builder.addMethod(&quot;obtain&quot;, {
      args: &quot;index; default&quot;
    }, function($index, $default) {
      if ($index.__num__() === 0) {
        return this;
      } else {
        return $default;
      }
    });

    builder.addMethod(&quot;instill&quot;, {
      args: &quot;index; item; default&quot;
    }, function($index, $item, $default) {
      if ($index.__num__() === 0) {
        return $item;
      } else {
        return this.asArray().instill($index, $item, $default);
      }
    });

    builder.addMethod(&quot;addFunc&quot;, {
      args: &quot;*functions&quot;
    }, function($$functions) {
      return $(&quot;FunctionList&quot;).new(this [&quot;++&quot;] ($$functions));
    });

    builder.addMethod(&quot;removeFunc&quot;, function($function) {
      if (this === $function) {
        return $nil;
      }
      return this;
    });

    builder.addMethod(&quot;replaceFunc&quot;, {
      args: &quot;find; replace&quot;
    }, function($find, $replace) {
      if (this === $find) {
        return $replace;
      }
      return this;
    });

    // TODO: implements addFuncTo
    // TODO: implements removeFuncFrom

    builder.addMethod(&quot;while&quot;, {
      args: &quot;body&quot;
    }, function($body) {
      var $this = this;

      $.Func(function() {
        return $this.value();
      }).while($.Func(function() {
        return $body.value();
      }));

      return this;
    });

    builder.addMethod(&quot;switch&quot;, function() {
      var args, i, imax;

      args = _.toArray(arguments);
      for (i = 0, imax = args.length &gt;&gt; 1; i &lt; imax; i++) {
        if (this [&quot;==&quot;] (args[i * 2]).__bool__()) {
          return args[i * 2 + 1].value();
        }
      }

      if (args.length % 2 === 1) {
        return args[args.length - 1].value();
      }

      return $nil;
    });

    builder.addMethod(&quot;yield&quot;, function() {
      sc.lang.bytecode.yield(this.value());
      return $nil;
    });

    builder.addMethod(&quot;alwaysYield&quot;, function() {
      sc.lang.bytecode.alwaysYield(this.value());
      return $nil;
    });

    builder.addMethod(&quot;yieldAndReset&quot;, function($reset) {
      if (!$reset || $reset === $true) {
        sc.lang.bytecode.yieldAndReset(this.value());
      } else {
        sc.lang.bytecode.yield(this.value());
      }
      return $nil;
    });

    // TODO: implements idle
    // TODO: implements $initClass
    // TODO: implements dependants
    // TODO: implements changed
    // TODO: implements addDependant
    // TODO: implements removeDependant
    // TODO: implements release
    // TODO: implements releaseDependants
    // TODO: implements update
    // TODO: implements addUniqueMethod
    // TODO: implements removeUniqueMethods
    // TODO: implements removeUniqueMethod
    // TODO: implements inspect
    // TODO: implements inspectorClass
    // TODO: implements inspector
    // TODO: implements crash
    // TODO: implements stackDepth
    // TODO: implements dumpStack
    // TODO: implements dumpDetailedBackTrace
    // TODO: implements freeze

    builder.addMethod(&quot;&amp;&quot;, function($that) {
      return this.$(&quot;bitAnd&quot;, [ $that ]);
    });

    builder.addMethod(&quot;|&quot;, function($that) {
      return this.$(&quot;bitOr&quot;, [ $that ]);
    });

    builder.addMethod(&quot;%&quot;, function($that) {
      return this.$(&quot;mod&quot;, [ $that ]);
    });

    builder.addMethod(&quot;**&quot;, function($that) {
      return this.$(&quot;pow&quot;, [ $that ]);
    });

    builder.addMethod(&quot;&lt;&lt;&quot;, function($that) {
      return this.$(&quot;leftShift&quot;, [ $that ]);
    });

    builder.addMethod(&quot;&gt;&gt;&quot;, function($that) {
      return this.$(&quot;rightShift&quot;, [ $that ]);
    });

    builder.addMethod(&quot;+&gt;&gt;&quot;, function($that) {
      return this.$(&quot;unsignedRightShift&quot; , [ $that ]);
    });

    builder.addMethod(&quot;&lt;!&quot;, function($that) {
      return this.$(&quot;firstArg&quot;, [ $that ]);
    });

    builder.addMethod(&quot;asInt&quot;, function() {
      return this.asInteger();
    });

    builder.addMethod(&quot;blend&quot;, {
      args: &quot;that; blendFrac=0.5&quot;
    }, function($that, $blendFrac) {
      return this.$(&quot;+&quot;, [ $blendFrac.$(&quot;*&quot;, [ $that.$(&quot;-&quot;, [ this ]) ]) ]);
    });

    builder.addMethod(&quot;blendAt&quot;, {
      args: &quot;index; method=\\clipAt&quot;
    }, function($index, $method) {
      var $iMin;

      $iMin = $index.$(&quot;roundUp&quot;, [ $int1 ]).asInteger().__dec__();
      return this.perform($method, $iMin).blend(
        this.perform($method, $iMin.__inc__()),
        $index.$(&quot;absdif&quot;, [ $iMin ])
      );
    });

    builder.addMethod(&quot;blendPut&quot;, {
      args: &quot;index; val; method=\\wrapPut&quot;
    }, function($index, $val, $method) {
      var $iMin, $ratio;

      $iMin = $index.$(&quot;floor&quot;).asInteger();
      $ratio = $index.$(&quot;absdif&quot;, [ $iMin ]);
      this.perform($method, $iMin, $val.$(&quot;*&quot;, [ $int1 [&quot;-&quot;] ($ratio) ]));
      this.perform($method, $iMin.__inc__(), $val.$(&quot;*&quot;, [ $ratio ]));

      return this;
    });

    builder.addMethod(&quot;fuzzyEqual&quot;, {
      args: &quot;that; precision=1.0&quot;
    }, function($that, $precision) {
      return $.Float(0.0).max(
        $.Float(1.0) [&quot;-&quot;] (
          this.$(&quot;-&quot;, [ $that ]).$(&quot;abs&quot;).$(&quot;/&quot;, [ $precision ])
        )
      );
    });

    builder.addMethod(&quot;isUGen&quot;, sc.FALSE);

    builder.addMethod(&quot;numChannels&quot;, function() {
      return $int1;
    });

    builder.addMethod(&quot;pair&quot;, {
      args: &quot;that&quot;
    }, function($that) {
      return $.Array([ this, $that ]);
    });

    builder.addMethod(&quot;pairs&quot;, {
      args: &quot;that&quot;
    }, function($that) {
      var $list;

      $list = $.Array();
      this.asArray().do($.Func(function($a) {
        return $that.asArray().do($.Func(function($b) {
          $list = $list.add($a.asArray() [&quot;++&quot;] ($b));
          return $list;
        }));
      }));

      return $list;
    });

    builder.addMethod(&quot;awake&quot;, {
      args: &quot;beats&quot;
    }, function($beats) {
      return this.next($beats);
    });

    builder.addMethod(&quot;beats_&quot;);
    builder.addMethod(&quot;clock_&quot;);

    builder.addMethod(&quot;performBinaryOpOnSomething&quot;, function($aSelector) {
      var aSelector;

      aSelector = $aSelector.__sym__();
      if (aSelector === &quot;==&quot;) {
        return $false;
      }
      if (aSelector === &quot;!=&quot;) {
        return $true;
      }

      throw new Error(strlib.format(&quot;binary operator &#039;#{0}&#039; failed.&quot;, aSelector));
    });

    builder.addMethod(&quot;performBinaryOpOnSimpleNumber&quot;, function($aSelector, $thig, $adverb) {
      return this.performBinaryOpOnSomething($aSelector, $thig, $adverb);
    });
    builder.addMethod(&quot;performBinaryOpOnSignal&quot;, function($aSelector, $thig, $adverb) {
      return this.performBinaryOpOnSomething($aSelector, $thig, $adverb);
    });
    builder.addMethod(&quot;performBinaryOpOnComplex&quot;, function($aSelector, $thig, $adverb) {
      return this.performBinaryOpOnSomething($aSelector, $thig, $adverb);
    });
    builder.addMethod(&quot;performBinaryOpOnSeqColl&quot;, function($aSelector, $thig, $adverb) {
      return this.performBinaryOpOnSomething($aSelector, $thig, $adverb);
    });
    builder.addMethod(&quot;performBinaryOpOnUGen&quot;, function($aSelector, $thig, $adverb) {
      return this.performBinaryOpOnSomething($aSelector, $thig, $adverb);
    });

    // TODO: implements writeDefFile

    builder.addMethod(&quot;isInputUGen&quot;, sc.FALSE);
    builder.addMethod(&quot;isOutputUGen&quot;, sc.FALSE);
    builder.addMethod(&quot;isControlUGen&quot;, sc.FALSE);
    builder.addMethod(&quot;source&quot;);
    builder.addMethod(&quot;asUGenInput&quot;);
    builder.addMethod(&quot;asControlInput&quot;);

    builder.addMethod(&quot;asAudioRateInput&quot;, function() {
      if (this.rate().__sym__() !== &quot;audio&quot;) {
        return $(&quot;K2A&quot;).ar(this);
      }
      return this;
    });

    // TODO: implements slotSize
    // TODO: implements slotAt
    // TODO: implements slotPut
    // TODO: implements slotKey
    // TODO: implements slotIndex
    // TODO: implements slotsDo
    // TODO: implements slotValuesDo
    // TODO: implements getSlots
    // TODO: implements setSlots
    // TODO: implements instVarSize
    // TODO: implements instVarAt
    // TODO: implements instVarPut
    // TODO: implements writeArchive
    // TODO: implements $readArchive
    // TODO: implements asArchive
    // TODO: implements initFromArchive
    // TODO: implements archiveAsCompileString
    // TODO: implements archiveAsObject
    // TODO: implements checkCanArchive
    // TODO: implements writeTextArchive
    // TODO: implements $readTextArchive
    // TODO: implements asTextArchive
    // TODO: implements getContainedObjects
    // TODO: implements writeBinaryArchive
    // TODO: implements $readBinaryArchive
    // TODO: implements asBinaryArchive
    // TODO: implements genNext
    // TODO: implements genCurrent
    // TODO: implements $classRedirect
    // TODO: implements help

    builder.addMethod(&quot;processRest&quot;);
  });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
