<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - classlib/Collections/SequenceableCollection.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>classlib/Collections/SequenceableCollection.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">125.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1996</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">136.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">25.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">SCScript.install(function(sc) {
  &quot;use strict&quot;;

  require(&quot;./Collection&quot;);

  var $ = sc.lang.$;
  var $nil   = $.nil;
  var $true  = $.true;
  var $false = $.false;
  var $int0  = $.int0;
  var $int1  = $.int1;
  var strlib = sc.libs.strlib;

  sc.lang.klass.refine(&quot;SequenceableCollection&quot;, function(builder, _) {
    builder.addMethod(&quot;|@|&quot;, function($index) {
      return this.clipAt($index);
    });

    builder.addMethod(&quot;@@&quot;, function($index) {
      return this.wrapAt($index);
    });

    builder.addMethod(&quot;@|@&quot;, function($index) {
      return this.foldAt($index);
    });

    builder.addClassMethod(&quot;series&quot;, {
      args: &quot;size; start=0; step=1&quot;
    }, function($size, $start, $step) {
      var $obj, i, imax;

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($start.$(&quot;+&quot;, [ $step.$(&quot;*&quot;, [ $.Integer(i) ]) ]));
      }

      return $obj;
    });

    builder.addClassMethod(&quot;geom&quot;, {
      args: &quot;size; start; grow&quot;
    }, function($size, $start, $grow) {
      var $obj, i, imax;

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($start);
        $start = $start.$(&quot;*&quot;, [ $grow ]);
      }

      return $obj;
    });

    builder.addClassMethod(&quot;fib&quot;, {
      args: &quot;size; a=0.0; b=1.0&quot;
    }, function($size, $a, $b) {
      var $obj, $temp, i, imax;

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($b);
        $temp = $b;
        $b = $a.$(&quot;+&quot;, [ $b ]);
        $a = $temp;
      }

      return $obj;
    });

    builder.addClassMethod(&quot;rand&quot;, {
      args: &quot;size; minVal=0.0; maxVal=1.0&quot;
    }, function($size, $minVal, $maxVal) {
      var $obj, i, imax;

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($minVal.rrand($maxVal));
      }

      return $obj;
    });

    builder.addClassMethod(&quot;exprand&quot;, {
      args: &quot;size; minVal=0.0; maxVal=1.0&quot;
    }, function($size, $minVal, $maxVal) {
      var $obj, i, imax;

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($minVal.exprand($maxVal));
      }

      return $obj;
    });

    builder.addClassMethod(&quot;rand2&quot;, {
      args: &quot;size; val=1.0&quot;
    }, function($size, $val) {
      var $obj, i, imax;

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($val.rand2());
      }

      return $obj;
    });

    builder.addClassMethod(&quot;linrand&quot;, {
      args: &quot;size; minVal; maxVal&quot;
    }, function($size, $minVal, $maxVal) {
      var $obj, i, imax;
      var $range;

      $range = $maxVal [&quot;-&quot;] ($minVal);

      $obj = this.new($size);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($minVal [&quot;+&quot;] ($range.linrand()));
      }

      return $obj;
    });

    builder.addClassMethod(&quot;interpolation&quot;, {
      args: &quot;size; start=0.0; end=1.0&quot;
    }, function($size, $start, $end) {
      var $obj, $step, i, imax;

      $obj = this.new($size);
      if ($size.__int__() === 1) {
        return $obj.add($start);
      }

      $step = ($end.$(&quot;-&quot;, [ $start ])).$(&quot;/&quot;, [ $size.__dec__() ]);
      for (i = 0, imax = $size.__int__(); i &lt; imax; ++i) {
        $obj.add($start.$(&quot;+&quot;, [ $.Integer(i) [&quot;*&quot;] ($step) ]));
      }

      return $obj;
    });

    builder.addMethod(&quot;++&quot;, function($aSequenceableCollection) {
      var $newlist;

      $newlist = this.species().new(this.size() [&quot;+&quot;] ($aSequenceableCollection.size()));
      $newlist = $newlist.addAll(this).addAll($aSequenceableCollection);

      return $newlist;
    });

    // TODO: implements +++

    builder.addMethod(&quot;asSequenceableCollection&quot;);

    builder.addMethod(&quot;choose&quot;, function() {
      return this.at(this.size().rand());
    });

    builder.addMethod(&quot;wchoose&quot;, {
      args: &quot;weights&quot;
    }, function($weights) {
      return this.at($weights.$(&quot;windex&quot;));
    });

    builder.addMethod(&quot;==&quot;, function($aCollection) {
      var $res = null;

      if ($aCollection.class() !== this.class()) {
        return $false;
      }
      if (this.size() !== $aCollection.size()) {
        return $false;
      }
      this.do($.Func(function($item, $i) {
        if ($item [&quot;!=&quot;] ($aCollection.$(&quot;at&quot;, [ $i ])).__bool__()) {
          $res = $false;
          this.break();
        }
        return $nil;
      }));

      return $res || $true;
    });

    // TODO: implements hash

    builder.addMethod(&quot;copyRange&quot;, {
      args: &quot;start; end&quot;
    }, function($start, $end) {
      var $newColl, i, end;

      i = $start.__int__();
      end = $end.__int__();
      $newColl = this.species().new($.Integer(end - i));
      while (i &lt;= end) {
        $newColl.add(this.at($.Integer(i++)));
      }

      return $newColl;
    });

    builder.addMethod(&quot;keep&quot;, {
      args: &quot;n&quot;
    }, function($n) {
      var n, size;

      n = $n.__int__();
      if (n &gt;= 0) {
        return this.copyRange($int0, $.Integer(n - 1));
      }
      size = this.size().__int__();

      return this.copyRange($.Integer(size + n), $.Integer(size - 1));
    });

    builder.addMethod(&quot;drop&quot;, {
      args: &quot;n&quot;
    }, function($n) {
      var n, size;

      n = $n.__int__();
      size = this.size().__int__();
      if (n &gt;= 0) {
        return this.copyRange($n, $.Integer(size - 1));
      }

      return this.copyRange($int0, $.Integer(size + n - 1));
    });

    builder.addMethod(&quot;copyToEnd&quot;, {
      args: &quot;start&quot;
    }, function($start) {
      return this.copyRange($start, $.Integer(this.size().__int__() - 1));
    });

    builder.addMethod(&quot;copyFromStart&quot;, {
      args: &quot;end&quot;
    }, function($end) {
      return this.copyRange($int0, $end);
    });

    builder.addMethod(&quot;indexOf&quot;, {
      args: &quot;item&quot;
    }, function($item) {
      var $ret = null;

      this.do($.Func(function($elem, $i) {
        if ($item === $elem) {
          $ret = $i;
          this.break();
        }
        return $nil;
      }));

      return $ret || $nil;
    });

    builder.addMethod(&quot;indicesOfEqual&quot;, {
      args: &quot;item&quot;
    }, function($item) {
      var indices = [];

      this.do($.Func(function($elem, $i) {
        if ($item === $elem) {
          indices.push($i);
        }
        return $nil;
      }));

      return indices.length ? $.Array(indices) : $nil;
    });

    builder.addMethod(&quot;find&quot;, {
      args: &quot;sublist; offset=0&quot;
    }, function($sublist, $offset) {
      var $subSize1, $first, $index;
      var size, offset, i, imax;

      $subSize1 = $sublist.size().__dec__();
      $first = $sublist.first();

      size   = this.size().__int__();
      offset = $offset.__int__();
      for (i = 0, imax = size - offset; i &lt; imax; ++i) {
        $index = $.Integer(i + offset);
        if (this.at($index) [&quot;==&quot;] ($first).__bool__()) {
          if (this.copyRange($index, $index [&quot;+&quot;] ($subSize1)) [&quot;==&quot;] ($sublist).__bool__()) {
            return $index;
          }
        }
      }

      return $nil;
    });

    builder.addMethod(&quot;findAll&quot;, {
      args: &quot;arr; offset=0&quot;
    }, function($arr, $offset) {
      var $this = this, $indices, $i;

      $indices = $nil;
      $i = $int0;

      while (($i = $this.find($arr, $offset)) !== $nil) {
        $indices = $indices.add($i);
        $offset = $i.__inc__();
      }

      return $indices;
    });

    builder.addMethod(&quot;indexOfGreaterThan&quot;, {
      args: &quot;val&quot;
    }, function($val) {
      return this.detectIndex($.Func(function($item) {
        return $.Boolean($item &gt; $val);
      }));
    });

    builder.addMethod(&quot;indexIn&quot;, {
      args: &quot;val&quot;
    }, function($val) {
      var $i, $j;

      $j = this.indexOfGreaterThan($val);
      if ($j === $nil) {
        return this.size().__dec__();
      }
      if ($j === $int0) {
        return $j;
      }

      $i = $j.__dec__();

      if ($val.$(&quot;-&quot;, [ this.at($i) ]) &lt; this.at($j).$(&quot;-&quot;, [ $val ])) {
        return $i;
      }

      return $j;
    });

    builder.addMethod(&quot;indexInBetween&quot;, {
      args: &quot;val&quot;
    }, function($val) {
      var $a, $b, $div, $i;

      if (this.isEmpty().__bool__()) {
        return $nil;
      }
      $i = this.indexOfGreaterThan($val);

      if ($i === $nil) {
        return this.size().__dec__();
      }
      if ($i === $int0) {
        return $i;
      }

      $a = this.at($i.__dec__());
      $b = this.at($i);
      $div = $b.$(&quot;-&quot;, [ $a ]);

      // if ($div [&quot;==&quot;] ($int0).__bool__()) {
      //   return $i;
      // }

      return $val.$(&quot;-&quot;, [ $a ]).$(&quot;/&quot;, [ $div ]).$(&quot;+&quot;, [ $i.__dec__() ]);
    });

    builder.addMethod(&quot;isSeries&quot;, {
      args: &quot;step&quot;
    }, function($step) {
      var $res = null;

      if (this.size() &lt;= 1) {
        return $true;
      }
      this.doAdjacentPairs($.Func(function($a, $b) {
        var $diff = $b.$(&quot;-&quot;, [ $a ]);
        if ($step === $nil) {
          $step = $diff;
        } else if ($step [&quot;!=&quot;] ($diff).__bool__()) {
          $res = $false;
          this.break();
        }
        return $nil;
      }));

      return $res || $true;
    });

    builder.addMethod(&quot;resamp0&quot;, {
      args: &quot;newSize&quot;
    }, function($newSize) {
      var $this = this, $factor;

      $factor = (
        this.size().__dec__()
      ) [&quot;/&quot;] (
        ($newSize.__dec__()).max($int1)
      );

      return this.species().fill($newSize, $.Func(function($i) {
        return $this.at($i [&quot;*&quot;] ($factor).round($.Float(1.0)).asInteger());
      }));
    });

    builder.addMethod(&quot;resamp1&quot;, {
      args: &quot;newSize&quot;
    }, function($newSize) {
      var $this = this, $factor;

      $factor = (
        this.size().__dec__()
      ) [&quot;/&quot;] (
        ($newSize.__dec__()).max($int1)
      );

      return this.species().fill($newSize, $.Func(function($i) {
        return $this.blendAt($i [&quot;*&quot;] ($factor));
      }));
    });

    builder.addMethod(&quot;remove&quot;, {
      args: &quot;item&quot;
    }, function($item) {
      var $index;

      $index = this.indexOf($item);
      if ($index !== $nil) {
        return this.removeAt($index);
      }

      return $nil;
    });

    builder.addMethod(&quot;removing&quot;, {
      args: &quot;item&quot;
    }, function($item) {
      var $coll;

      $coll = this.copy();
      $coll.remove($item);

      return $coll;
    });

    builder.addMethod(&quot;take&quot;, {
      args: &quot;item&quot;
    }, function($item) {
      var $index;

      $index = this.indexOf($item);
      if ($index !== $nil) {
        return this.takeAt($index);
      }

      return $nil;
    });

    builder.addMethod(&quot;lastIndex&quot;, function() {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return $.Integer(size - 1);
      }

      return $nil;
    });

    builder.addMethod(&quot;middleIndex&quot;, function() {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return $.Integer((size - 1) &gt;&gt; 1);
      }

      return $nil;
    });

    builder.addMethod(&quot;first&quot;, function() {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return this.at($int0);
      }

      return $nil;
    });

    builder.addMethod(&quot;last&quot;, function() {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return this.at($.Integer(size - 1));
      }

      return $nil;
    });

    builder.addMethod(&quot;middle&quot;, function() {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return this.at($.Integer((size - 1) &gt;&gt; 1));
      }

      return $nil;
    });

    builder.addMethod(&quot;top&quot;, function() {
      return this.last();
    });

    builder.addMethod(&quot;putFirst&quot;, {
      args: &quot;obj&quot;
    }, function($obj) {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return this.put($int0, $obj);
      }

      return this;
    });

    builder.addMethod(&quot;putLast&quot;, {
      args: &quot;obj&quot;
    }, function($obj) {
      var size = this.size().__int__();

      if (size &gt; 0) {
        return this.put($.Integer(size - 1), $obj);
      }

      return this;
    });

    builder.addMethod(&quot;obtain&quot;, {
      args: &quot;index; default&quot;
    }, function($index, $default) {
      var $res;

      $res = this.at($index);
      if ($res === $nil) {
        $res = $default;
      }

      return $res;
    });

    builder.addMethod(&quot;instill&quot;, {
      args: &quot;index; item; default&quot;
    }, function($index, $item, $default) {
      var $res;

      if ($index.__num__() &gt;= this.size()) {
        $res = this.extend($index.__inc__(), $default);
      } else {
        $res = this.copy();
      }

      return $res.put($index, $item);
    });

    builder.addMethod(&quot;pairsDo&quot;, function($function) {
      var $this = this, $int2 = $.Integer(2);

      $int0.forBy(this.size() [&quot;-&quot;] ($int2), $int2, $.Func(function($i) {
        return $function.value($this.at($i), $this.at($i.__inc__()), $i);
      }));

      return this;
    });

    builder.addMethod(&quot;keysValuesDo&quot;, function($function) {
      return this.pairsDo($function);
    });

    builder.addMethod(&quot;doAdjacentPairs&quot;, function($function) {
      var $i;
      var size, i, imax;

      size = this.size().__int__();
      for (i = 0, imax = size - 1; i &lt; imax; ++i) {
        $i = $.Integer(i);
        $function.value(this.at($i), this.at($i.__inc__()), $i);
      }

      return this;
    });

    builder.addMethod(&quot;separate&quot;, {
      args: &quot;function=true&quot;
    }, function($function) {
      var $this = this, $list, $sublist;

      $list = $.Array();
      $sublist = this.species().new();
      this.doAdjacentPairs($.Func(function($a, $b, $i) {
        $sublist = $sublist.add($a);
        if ($function.value($a, $b, $i).__bool__()) {
          $list = $list.add($sublist);
          $sublist = $this.species().new();
        }
        return $nil;
      }));
      if (this.notEmpty().__bool__()) {
        $sublist = $sublist.add(this.last());
      }
      $list = $list.add($sublist);

      return $list;
    });

    builder.addMethod(&quot;delimit&quot;, function($function) {
      var $this = this, $list, $sublist;

      $list = $.Array();
      $sublist = this.species().new();
      this.do($.Func(function($item, $i) {
        if ($function.value($item, $i).__bool__()) {
          $list = $list.add($sublist);
          $sublist = $this.species().new();
        } else {
          $sublist = $sublist.add($item);
        }
        return $nil;
      }));
      $list = $list.add($sublist);

      return $list;
    });

    builder.addMethod(&quot;clump&quot;, {
      args: &quot;groupSize&quot;
    }, function($groupSize) {
      var $this = this, $list, $sublist;

      $list = $.Array();
      $sublist = this.species().new($groupSize);
      this.do($.Func(function($item) {
        $sublist.add($item);
        if ($sublist.size() &gt;= $groupSize) {
          $list.add($sublist);
          $sublist = $this.species().new($groupSize);
        }
        return $nil;
      }));
      if ($sublist.size() &gt; 0) {
        $list = $list.add($sublist);
      }

      return $list;
    });

    builder.addMethod(&quot;clumps&quot;, {
      args: &quot;groupSizeList&quot;
    }, function($groupSizeList) {
      var $this = this, $list, $subSize, $sublist, i = 0;

      $list = $.Array();
      $subSize = $groupSizeList.at($int0);
      $sublist = this.species().new($subSize);
      this.do($.Func(function($item) {
        $sublist = $sublist.add($item);
        if ($sublist.size() &gt;= $subSize) {
          $list = $list.add($sublist);
          $subSize = $groupSizeList.$(&quot;wrapAt&quot;, [ $.Integer(++i) ]);
          $sublist = $this.species().new($subSize);
        }
        return $nil;
      }));
      if ($sublist.size() &gt; 0) {
        $list = $list.add($sublist);
      }

      return $list;
    });

    builder.addMethod(&quot;curdle&quot;, {
      args: &quot;probability&quot;
    }, function($probability) {
      return this.separate($.Func(function() {
        return $probability.$(&quot;coin&quot;);
      }));
    });

    builder.addMethod(&quot;flatten&quot;, {
      args: &quot;numLevels=1&quot;
    }, function($numLevels) {
      return flatten(this, $numLevels.__num__());
    });

    function flatten($this, numLevels) {
      var $list;

      if (numLevels &lt;= 0) {
        return $this;
      }
      numLevels = numLevels - 1;

      $list = $this.species().new();
      $this.do($.Func(function($item) {
        if ($item.flatten) {
          $list = $list.addAll(flatten($item, numLevels));
        } else {
          $list = $list.add($item);
        }
        return $nil;
      }));

      return $list;
    }

    builder.addMethod(&quot;flat&quot;, function() {
      return flat(this, this.species().new(this.flatSize()));
    });

    function flat($this, $list) {
      $this.do($.Func(function($item) {
        if ($item.flat) {
          $list = flat($item, $list);
        } else {
          $list = $list.add($item);
        }
        return $nil;
      }));
      return $list;
    }

    builder.addMethod(&quot;flatIf&quot;, function($func) {
      return flatIf(this, $func);
    });

    function flatIf($this, $func) {
      var $list;

      $list = $this.species().new($this.size());
      $this.do($.Func(function($item, $i) {
        if ($item.flatIf &amp;&amp; $func.value($item, $i).__bool__()) {
          $list = $list.addAll(flatIf($item, $func));
        } else {
          $list = $list.add($item);
        }
        return $nil;
      }));

      return $list;
    }

    builder.addMethod(&quot;flop&quot;, function() {
      var $this = this, $list, $size, $maxsize;

      $size = this.size();
      $maxsize = $int0;
      this.do($.Func(function($sublist) {
        var $sz;
        if ($sublist.isSequenceableCollection().__bool__()) {
          $sz = $sublist.size();
        } else {
          $sz = $int1;
        }
        if ($sz &gt; $maxsize) {
          $maxsize = $sz;
        }
        return $nil;
      }));

      $list = this.species().fill($maxsize, $.Func(function() {
        return $this.species().new($size);
      }));

      this.do($.Func(function($isublist) {
        if ($isublist.isSequenceableCollection().__bool__()) {
          $list.do($.Func(function($jsublist, $j) {
            return $jsublist.add($isublist.wrapAt($j));
          }));
        } else {
          $list.do($.Func(function($jsublist) {
            return $jsublist.add($isublist);
          }));
        }
        return $nil;
      }));

      return $list;
    });

    builder.addMethod(&quot;flopWith&quot;, {
      args: &quot;func&quot;
    }, function($func) {
      var $this = this, $maxsize;

      $maxsize = this.maxValue($.Func(function($sublist) {
        if ($sublist.isSequenceableCollection().__bool__()) {
          return $sublist.size();
        }
        return $int1;
      }));

      return this.species().fill($maxsize, $.Func(function($i) {
        return $func.valueArray($this.collect($.Func(function($sublist) {
          if ($sublist.isSequenceableCollection().__bool__()) {
            return $sublist.wrapAt($i);
          }
          return $sublist;
        })));
      }));
    });

    builder.addMethod(&quot;flopTogether&quot;, function() {
      var $standIn, $minus1, $looper;
      var array, maxSize = 0;

      array = [ this ].concat(_.toArray(arguments));
      array.forEach(function($sublist) {
        $sublist.do($.Func(function($each) {
          var size = $each.size();
          if (maxSize &lt; size) {
            maxSize = size;
          }
          return $nil;
        }));
      });

      $standIn = $int0.dup($.Integer(maxSize));
      $minus1  = $.Integer(-1);
      $looper  = $.Func(function($each) {
        return $each.drop($minus1);
      });

      return $.Array(array.map(function($sublist) {
        return $sublist.add($standIn);
      })).collect($.Func(function($sublist) {
        return $sublist.flop().collect($looper);
      }));
    });

    builder.addMethod(&quot;flopDeep&quot;, {
      args: &quot;rank&quot;
    }, function($rank) {
      var $this = this;
      var $size, $maxsize;

      if ($rank === $nil) {
        $rank = this.maxDepth().__dec__();
      }
      if ($rank.__int__() &lt;= 1) {
        return this.flop();
      }

      $size = this.size();
      $maxsize = this.maxSizeAtDepth($rank);

      return this.species().fill($maxsize, $.Func(function($i) {
        return $this.wrapAtDepth($rank, $i);
      }));
    });

    builder.addMethod(&quot;wrapAtDepth&quot;, {
      args: &quot;rank; index&quot;
    }, function($rank, $index) {
      if ($rank === $int0) {
        return this.wrapAt($index);
      }
      return this.collect($.Func(function($item) {
        if ($item.isSequenceableCollection().__bool__()) {
          return $item.wrapAtDepth($rank.__dec__(), $index);
        }
        return $item;
      }));
    });

    builder.addMethod(&quot;unlace&quot;, {
      args: &quot;numlists; clumpSize=1; clip=false&quot;
    }, function($numlists, $clumpSize, $clip) {
      var $this = this;
      var $size, $list, $self, $sublist;

      $size = (this.size() [&quot;+&quot;] ($numlists.__dec__())).div($numlists);
      $list = this.species().fill($numlists, $.Func(function() {
        return $this.species().new($size);
      }));
      if ($clip.__bool__()) {
        $self = this.keep(this.size().trunc($clumpSize [&quot;*&quot;] ($numlists)));
      } else {
        $self = this;
      }
      $self.do($.Func(function($item, $i) {
        $sublist = $list.at($i.div($clumpSize) [&quot;%&quot;] ($numlists));
        return $sublist.add($item);
      }));
      return $list;
    });

    builder.addMethod(&quot;integrate&quot;, function() {
      var $list, $sum;

      $sum = $int0;

      $list = this.class().new(this.size());
      this.do($.Func(function($item) {
        $sum = $sum [&quot;+&quot;] ($item);
        return $list.add( $sum );
      }));

      return $list;
    });

    builder.addMethod(&quot;differentiate&quot;, function() {
      var $list, $prev;

      $prev = $int0;

      $list = this.class().new(this.size());
      this.do($.Func(function($item) {
        $list.add($item [&quot;-&quot;] ($prev));
        $prev = $item;
        return $item;
      }));

      return $list;
    });

    builder.addMethod(&quot;convertDigits&quot;, {
      args: &quot;base=10&quot;
    }, function($base) {
      var $lastIndex;

      $lastIndex = this.lastIndex();
      return this.sum($.Func(function($x, $i) {
        if ($x.__int__() &gt;= $base.__int__()) {
          throw new Error(&quot;digit too large for base&quot;);
        }
        return $base [&quot;**&quot;] ($lastIndex [&quot;-&quot;] ($i)) [&quot;*&quot;] ($x);
      })).asInteger();
    });

    builder.addMethod(&quot;hammingDistance&quot;, {
      args: &quot;that&quot;
    }, function($that) {
      var count;

      count = Math.max(0, $that.size().__int__() - this.size().__int__());
      this.do($.Func(function($elem, $i) {
        if ($elem [&quot;!=&quot;] ($that.at($i)).__bool__()) {
          count += 1;
        }
        return $nil;
      }));

      return $.Integer(count);
    });

    builder.addMethod(&quot;degreeToKey&quot;, {
      args: &quot;scale; stepsPerOctave=12&quot;
    }, function($scale, $stepsPerOctave) {
      return this.collect($.Func(function($scaleDegree) {
        return $scaleDegree.degreeToKey($scale, $stepsPerOctave);
      }));
    });

    builder.addMethod(&quot;keyToDegree&quot;, {
      args: &quot;scale; stepsPerOctave=12&quot;
    }, function($scale, $stepsPerOctave) {
      return this.collect($.Func(function($val) {
        return $val.keyToDegree($scale, $stepsPerOctave);
      }));
    });

    builder.addMethod(&quot;nearestInScale&quot;, {
      args: &quot;scale; stepsPerOctave=12&quot;
    }, function($scale, $stepsPerOctave) {
      var $root, $key;
      $root = this.trunc($stepsPerOctave);
      $key = this [&quot;%&quot;] ($stepsPerOctave);
      return $key.nearestInList($scale) [&quot;+&quot;] ($root);
    });

    builder.addMethod(&quot;nearestInList&quot;, {
      args: &quot;list&quot;
    }, function($list) {
      return this.collect($.Func(function($item) {
        return $list.at($list.indexIn($item));
      }));
    });

    builder.addMethod(&quot;transposeKey&quot;, {
      args: &quot;amount; octave=12&quot;
    }, function($amount, $octave) {
      return ((this [&quot;+&quot;] ($amount)) [&quot;%&quot;] ($octave)).sort();
    });

    builder.addMethod(&quot;mode&quot;, {
      args: &quot;degree; octave=12&quot;
    }, function($degree, $octave) {
      return (this.rotate($degree.neg()) [&quot;-&quot;] (this.wrapAt($degree))) [&quot;%&quot;] ($octave);
    });

    builder.addMethod(&quot;performDegreeToKey&quot;, {
      args: &quot;scaleDegree; stepsPerOctave=12; accidental=0&quot;
    }, function($scaleDegree, $stepsPerOctave, $accidental) {
      var $baseKey;

      $baseKey = (
        $stepsPerOctave [&quot;*&quot;] ($scaleDegree.div(this.size()))
      ) [&quot;+&quot;] (this.wrapAt($scaleDegree));
      if ($accidental.__num__() === 0) {
        return $baseKey;
      }
      return $baseKey [&quot;+&quot;] ($accidental [&quot;*&quot;] ($stepsPerOctave [&quot;/&quot;] ($.Float(12.0))));
    });

    builder.addMethod(&quot;performKeyToDegree&quot;, {
      args: &quot;degree; stepsPerOctave=12&quot;
    }, function($degree, $stepsPerOctave) {
      var $n, $key;

      $n = $degree.div($stepsPerOctave) [&quot;*&quot;] (this.size());
      $key = $degree [&quot;%&quot;] ($stepsPerOctave);
      return this.indexInBetween($key) [&quot;+&quot;] ($n);
    });

    builder.addMethod(&quot;performNearestInList&quot;, {
      args: &quot;degree&quot;
    }, function($degree) {
      return this.at(this.indexIn($degree));
    });

    builder.addMethod(&quot;performNearestInScale&quot;, {
      args: &quot;degree; stepsPerOctave=12&quot;
    }, function($degree, $stepsPerOctave) {
      var $root, $key;
      $root = $degree.trunc($stepsPerOctave);
      $key  = $degree [&quot;%&quot;] ($stepsPerOctave);
      return $key.nearestInList(this) [&quot;+&quot;] ($root);
    });

    // TODO: implements convertRhythm
    // TODO: implements sumRhythmDivisions
    // TODO: implements convertOneRhythm

    builder.addMethod(&quot;isSequenceableCollection&quot;, sc.TRUE);

    builder.addMethod(&quot;containsSeqColl&quot;, function() {
      return this.any($.Func(function($_) {
        return $_.isSequenceableCollection();
      }));
    });

    builder.addMethod(&quot;neg&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;neg&quot;));
    });

    builder.addMethod(&quot;bitNot&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;bitNot&quot;));
    });

    builder.addMethod(&quot;abs&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;abs&quot;));
    });

    builder.addMethod(&quot;ceil&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;ceil&quot;));
    });

    builder.addMethod(&quot;floor&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;floor&quot;));
    });

    builder.addMethod(&quot;frac&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;frac&quot;));
    });

    builder.addMethod(&quot;sign&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;sign&quot;));
    });

    builder.addMethod(&quot;squared&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;squared&quot;));
    });

    builder.addMethod(&quot;cubed&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;cubed&quot;));
    });

    builder.addMethod(&quot;sqrt&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;sqrt&quot;));
    });

    builder.addMethod(&quot;exp&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;exp&quot;));
    });

    builder.addMethod(&quot;reciprocal&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;reciprocal&quot;));
    });

    builder.addMethod(&quot;midicps&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;midicps&quot;));
    });

    builder.addMethod(&quot;cpsmidi&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;cpsmidi&quot;));
    });

    builder.addMethod(&quot;midiratio&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;midiratio&quot;));
    });

    builder.addMethod(&quot;ratiomidi&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;ratiomidi&quot;));
    });

    builder.addMethod(&quot;ampdb&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;ampdb&quot;));
    });

    builder.addMethod(&quot;dbamp&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;dbamp&quot;));
    });

    builder.addMethod(&quot;octcps&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;octcps&quot;));
    });

    builder.addMethod(&quot;cpsoct&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;cpsoct&quot;));
    });

    builder.addMethod(&quot;log&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;log&quot;));
    });

    builder.addMethod(&quot;log2&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;log2&quot;));
    });

    builder.addMethod(&quot;log10&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;log10&quot;));
    });

    builder.addMethod(&quot;sin&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;sin&quot;));
    });

    builder.addMethod(&quot;cos&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;cos&quot;));
    });

    builder.addMethod(&quot;tan&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;tan&quot;));
    });

    builder.addMethod(&quot;asin&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;asin&quot;));
    });

    builder.addMethod(&quot;acos&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;acos&quot;));
    });

    builder.addMethod(&quot;atan&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;atan&quot;));
    });

    builder.addMethod(&quot;sinh&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;sinh&quot;));
    });

    builder.addMethod(&quot;cosh&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;cosh&quot;));
    });

    builder.addMethod(&quot;tanh&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;tanh&quot;));
    });

    builder.addMethod(&quot;rand&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;rand&quot;));
    });

    builder.addMethod(&quot;rand2&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;rand2&quot;));
    });

    builder.addMethod(&quot;linrand&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;linrand&quot;));
    });

    builder.addMethod(&quot;bilinrand&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;bilinrand&quot;));
    });

    builder.addMethod(&quot;sum3rand&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;sum3rand&quot;));
    });

    builder.addMethod(&quot;distort&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;distort&quot;));
    });

    builder.addMethod(&quot;softclip&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;softclip&quot;));
    });

    builder.addMethod(&quot;coin&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;coin&quot;));
    });

    builder.addMethod(&quot;even&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;even&quot;));
    });

    builder.addMethod(&quot;odd&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;odd&quot;));
    });

    builder.addMethod(&quot;isPositive&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;isPositive&quot;));
    });

    builder.addMethod(&quot;isNegative&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;isNegative&quot;));
    });

    builder.addMethod(&quot;isStrictlyPositive&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;isStrictlyPositive&quot;));
    });

    builder.addMethod(&quot;rectWindow&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;rectWindow&quot;));
    });

    builder.addMethod(&quot;hanWindow&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;hanWindow&quot;));
    });

    builder.addMethod(&quot;welWindow&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;welWindow&quot;));
    });

    builder.addMethod(&quot;triWindow&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;triWindow&quot;));
    });

    builder.addMethod(&quot;scurve&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;scurve&quot;));
    });

    builder.addMethod(&quot;ramp&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;ramp&quot;));
    });

    builder.addMethod(&quot;asFloat&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;asFloat&quot;));
    });

    builder.addMethod(&quot;asInteger&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;asInteger&quot;));
    });

    builder.addMethod(&quot;nthPrime&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;nthPrime&quot;));
    });

    builder.addMethod(&quot;prevPrime&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;prevPrime&quot;));
    });

    builder.addMethod(&quot;nextPrime&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;nextPrime&quot;));
    });

    builder.addMethod(&quot;indexOfPrime&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;indexOfPrime&quot;));
    });

    builder.addMethod(&quot;real&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;real&quot;));
    });

    builder.addMethod(&quot;imag&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;imag&quot;));
    });

    builder.addMethod(&quot;magnitude&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;magnitude&quot;));
    });

    builder.addMethod(&quot;magnitudeApx&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;magnitudeApx&quot;));
    });

    builder.addMethod(&quot;phase&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;phase&quot;));
    });

    builder.addMethod(&quot;angle&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;angle&quot;));
    });

    builder.addMethod(&quot;rho&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;rho&quot;));
    });

    builder.addMethod(&quot;theta&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;theta&quot;));
    });

    builder.addMethod(&quot;degrad&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;degrad&quot;));
    });

    builder.addMethod(&quot;raddeg&quot;, function() {
      return this.performUnaryOp($.Symbol(&quot;raddeg&quot;));
    });

    builder.addMethod(&quot;+&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;+&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;-&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;-&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;*&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;*&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;/&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;/&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;div&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;div&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;mod&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;mod&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;pow&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;pow&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;min&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;min&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;max&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;max&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;&lt;&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;&lt;&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;&lt;=&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;&lt;=&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;&gt;&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;&gt;&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;&gt;=&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;&gt;=&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;bitAnd&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;bitAnd&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;bitOr&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;bitOr&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;bitXor&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;bitXor&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;bitHammingDistance&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;bitHammingDistance&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;lcm&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;lcm&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;gcd&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;gcd&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;round&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;round&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;roundUp&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;roundUp&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;trunc&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;trunc&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;atan2&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;atan2&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;hypot&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;hypot&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;hypotApx&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;hypotApx&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;leftShift&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;leftShift&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;rightShift&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;rightShift&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;unsignedRightShift&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;unsignedRightShift&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;ring1&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;ring1&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;ring2&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;ring2&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;ring3&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;ring3&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;ring4&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;ring4&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;difsqr&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;difsqr&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;sumsqr&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;sumsqr&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;sqrsum&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;sqrsum&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;sqrdif&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;sqrdif&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;absdif&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;absdif&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;thresh&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;thresh&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;amclip&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;amclip&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;scaleneg&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;scaleneg&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;clip2&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;clip2&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;fold2&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;fold2&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;wrap2&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;wrap2&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;excess&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;excess&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;firstArg&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;firstArg&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;rrand&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;rrand&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;exprand&quot;, function($aNumber, $adverb) {
      return this.performBinaryOp($.Symbol(&quot;exprand&quot;), $aNumber, $adverb);
    });

    builder.addMethod(&quot;performUnaryOp&quot;, function($aSelector) {
      return this.collect($.Func(function($item) {
        return $item.perform($aSelector);
      }));
    });

    builder.addMethod(&quot;performBinaryOp&quot;, function($aSelector, $theOperand, $adverb) {
      return $theOperand.performBinaryOpOnSeqColl($aSelector, this, $adverb);
    });

    builder.addMethod(&quot;performBinaryOpOnSeqColl&quot;, function($aSelector, $theOperand, $adverb) {
      var adverb;

      if ($adverb === $nil || !$adverb) {
        return _performBinaryOpOnSeqColl$adverb$nil(
          this, $aSelector, $theOperand
        );
      }
      if ($adverb.isInteger().__bool__()) {
        return _performBinaryOpOnSeqColl$adverb$int(
          this, $aSelector, $theOperand, $adverb.__int__()
        );
      }

      adverb = $adverb.__sym__();
      if (adverb === &quot;t&quot;) {
        return _performBinaryOpOnSeqColl$adverb$t(
          this, $aSelector, $theOperand
        );
      }
      if (adverb === &quot;x&quot;) {
        return _performBinaryOpOnSeqColl$adverb$x(
          this, $aSelector, $theOperand
        );
      }
      if (adverb === &quot;s&quot;) {
        return _performBinaryOpOnSeqColl$adverb$s(
          this, $aSelector, $theOperand
        );
      }
      if (adverb === &quot;f&quot;) {
        return _performBinaryOpOnSeqColl$adverb$f(
          this, $aSelector, $theOperand
        );
      }

      throw new Error(strlib.format(
        &quot;unrecognized adverb: &#039;#{0}&#039; for operator &#039;#{1}&#039;&quot;, adverb, $aSelector
      ));
    });

    function _performBinaryOpOnSeqColl$adverb$nil($this, $aSelector, $theOperand) {
      var $size, $newList, $i;
      var size, i;

      $size = $this.size().max($theOperand.size());
      $newList = $this.species().new($size);

      size = $size.__int__();
      for (i = 0; i &lt; size; ++i) {
        $i = $.Integer(i);
        $newList.add(
          $theOperand.wrapAt($i).perform($aSelector, $this.wrapAt($i))
        );
      }

      return $newList;
    }

    function _performBinaryOpOnSeqColl$adverb$int($this, $aSelector, $theOperand, adverb) {
      var $size, $newList, $i;
      var size, i;

      if (adverb === 0) {
        $size = $this.size().max($theOperand.size());
        $newList = $this.species().new($size);

        size = $size.__int__();
        for (i = 0; i &lt; size; ++i) {
          $i = $.Integer(i);
          $newList.add($theOperand.wrapAt($i).perform($aSelector, $this.wrapAt($i)));
        }
      } else if (adverb &gt; 0) {
        $newList = $theOperand.collect($.Func(function($item) {
          return $item.perform($aSelector, $this, $.Integer(adverb - 1));
        }));
      } else {
        $newList = $this.collect($.Func(function($item) {
          return $theOperand.perform($aSelector, $item, $.Integer(adverb + 1));
        }));
      }

      return $newList;
    }

    function _performBinaryOpOnSeqColl$adverb$t($this, $aSelector, $theOperand) {
      var $size, $newList, $i;
      var size, i;

      $size = $theOperand.size();
      $newList = $this.species().new($size);

      size = $size.__int__();
      for (i = 0; i &lt; size; ++i) {
        $i = $.Integer(i);
        $newList.add($theOperand.at($i).perform($aSelector, $this));
      }

      return $newList;
    }

    function _performBinaryOpOnSeqColl$adverb$x($this, $aSelector, $theOperand) {
      var $size, $newList;

      $size = $theOperand.size() [&quot;*&quot;] ($this.size());
      $newList = $this.species().new($size);
      $theOperand.do($.Func(function($a) {
        return $this.do($.Func(function($b) {
          return $newList.add($a.perform($aSelector, $b));
        }));
      }));

      return $newList;
    }

    function _performBinaryOpOnSeqColl$adverb$s($this, $aSelector, $theOperand) {
      var $size, $newList, $i;
      var size, i;

      $size = $this.size().min($theOperand.size());
      $newList = $this.species().new($size);

      size = $size.__int__();
      for (i = 0; i &lt; size; ++i) {
        $i = $.Integer(i);
        $newList.add($theOperand.wrapAt($i).perform($aSelector, $this.wrapAt($i)));
      }

      return $newList;
    }

    function _performBinaryOpOnSeqColl$adverb$f($this, $aSelector, $theOperand) {
      var $size, $newList, $i;
      var size, i;

      $size = $this.size().max($theOperand.size());
      $newList = $this.species().new($size);

      size = $size.__int__();
      for (i = 0; i &lt; size; ++i) {
        $i = $.Integer(i);
        $newList.add($theOperand.foldAt($i).perform($aSelector, $this.foldAt($i)));
      }

      return $newList;
    }

    builder.addMethod(&quot;performBinaryOpOnSimpleNumber&quot;, function($aSelector, $aNumber, $adverb) {
      return this.collect($.Func(function($item) {
        return $aNumber.perform($aSelector, $item, $adverb);
      }));
    });

    builder.addMethod(&quot;performBinaryOpOnComplex&quot;, function($aSelector, $aComplex, $adverb) {
      return this.collect($.Func(function($item) {
        return $aComplex.perform($aSelector, $item, $adverb);
      }));
    });

    builder.addMethod(&quot;asFraction&quot;, function($denominator, $fasterBetter) {
      return this.collect($.Func(function($item) {
        return $item.$(&quot;asFraction&quot;, [ $denominator, $fasterBetter ] );
      }));
    });

    // TODO: implements asPoint
    // TODO: implements asRect

    builder.addMethod(&quot;ascii&quot;, function() {
      return this.collect($.Func(function($item) {
        return $item.$(&quot;ascii&quot;);
      }));
    });

    builder.addMethod(&quot;rate&quot;, function() {
      if (this.size().__int__() === 1) {
        return this.first().$(&quot;rate&quot;);
      }
      return this.collect($.Func(function($item) {
        return $item.$(&quot;rate&quot;);
      })).minItem();
    });

    builder.addMethod(&quot;multiChannelPerform&quot;, function() {
      if (this.size().__int__() &gt; 0) {
        return this.__super__(&quot;multiChannelPerform&quot;, arguments);
      }
      return this.class().new();
    });

    builder.addMethod(&quot;multichannelExpandRef&quot;);

    builder.addMethod(&quot;clip&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;clip&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;wrap&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;wrap&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;fold&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;fold&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;linlin&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;linlin&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;linexp&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;linexp&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;explin&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;explin&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;expexp&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;expexp&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lincurve&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lincurve&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;curvelin&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;curvelin&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;bilin&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;bilin&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;biexp&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;biexp&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;moddif&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;moddif&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;range&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;range&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;exprange&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;exprange&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;curverange&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;curverange&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;unipolar&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;unipolar&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;bipolar&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;bipolar&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lag&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lag&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lag2&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lag2&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lag3&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lag3&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lagud&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lagud&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lag2ud&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lag2ud&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;lag3ud&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;lag3ud&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;varlag&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;varlag&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;slew&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;slew&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;blend&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;blend&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;checkBadValues&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;checkBadValues&quot;) ].concat(_.toArray(arguments))
      );
    });

    builder.addMethod(&quot;prune&quot;, function() {
      return this.multiChannelPerform.apply(
        this, [ $.Symbol(&quot;prune&quot;) ].concat(_.toArray(arguments))
      );
    });

    // TODO: implements minNyquist

    builder.addMethod(&quot;sort&quot;, {
      args: &quot;function&quot;
    }, function($function) {
      if ($function === $nil) {
        $function = $.Func(function($a, $b) {
          return $a.$(&quot;&lt;=&quot;, [ $b ]);
        });
      }
      this.__sort__($function);
      return this;
    });

    builder.addMethod(&quot;sortBy&quot;, {
      args: &quot;key&quot;
    }, function($key) {
      return this.sort($.Func(function($a, $b) {
        return $a.$(&quot;at&quot;, [ $key ]).$(&quot;&lt;=&quot;, [ $b.$(&quot;at&quot;, [ $key ]) ]);
      }));
    });

    builder.addMethod(&quot;sortMap&quot;, {
      args: &quot;function&quot;
    }, function($function) {
      return this.sort($.Func(function($a, $b) {
        return $function.value($a).$(&quot;&lt;=&quot;, [ $function.value($b) ]);
      }));
    });

    // TODO: implements sortedMedian
    // TODO: implements median
    // TODO: implements quickSort
    // TODO: implements order

    builder.addMethod(&quot;swap&quot;, {
      args: &quot;i; j&quot;
    }, function($i, $j) {
      var $temp;

      $temp = this.at($i);
      this.put($i, this.at($j));
      this.put($j, $temp);

      return this;
    });

    // TODO: implements quickSortRange
    // TODO: implements mergeSort
    // TODO: implements mergeSortTemp
    // TODO: implements mergeTemp
    // TODO: implements insertionSort
    // TODO: implements insertionSortRange
    // TODO: implements hoareMedian
    // TODO: implements hoareFind
    // TODO: implements hoarePartition
    // TODO: implements $streamContensts
    // TODO: implements $streamContenstsLimit

    builder.addMethod(&quot;wrapAt&quot;, {
      args: &quot;index&quot;
    }, function($index) {
      $index = $index.$(&quot;%&quot;, [ this.size() ]);
      return this.at($index);
    });

    builder.addMethod(&quot;wrapPut&quot;, {
      args: &quot;index; value&quot;
    }, function($index, $value) {
      $index = $index.$(&quot;%&quot;, [ this.size() ]);
      return this.put($index, $value);
    });

    builder.addMethod(&quot;reduce&quot;, {
      args: &quot;operator&quot;
    }, function($operator) {
      var once;
      var $result;

      if (this.size().__int__() === 1) {
        return this.at($int0);
      }

      once = true;
      $result = $nil;
      this.doAdjacentPairs($.Func(function($a, $b) {
        if (once) {
          once = false;
          $result = $operator.applyTo($a, $b);
        } else {
          $result = $operator.applyTo($result, $b);
        }
        return $nil;
      }));

      return $result;
    });

    builder.addMethod(&quot;join&quot;, {
      args: &quot;joiner&quot;
    }, function($joiner) {
      var items, joiner;

      items = [];
      this.do($.Func(function($item) {
        items.push($item.__str__());
        return $nil;
      }));

      joiner = ($joiner === $nil) ? &quot;&quot; : $joiner.__str__();

      return $.String(items.join(joiner), true);
    });
    // TODO: implements nextTimeOnGrid
    // TODO: implements asQuant
    // TODO: implements schedBundleArrayOnClock
  });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
