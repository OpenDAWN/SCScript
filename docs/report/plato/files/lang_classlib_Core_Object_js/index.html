<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lang/classlib/Core/Object.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lang/classlib/Core/Object.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">124.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">696</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">57.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.18</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(sc) {
  &quot;use strict&quot;;

  require(&quot;../../classlib&quot;);

  var slice = [].slice;
  var $SC = sc.lang.$SC;
  var fn = sc.lang.fn;

  sc.lang.klass.refine(&quot;Object&quot;, function(spec, utils) {
    var bool = utils.bool;
    var $nil = utils.nilInstance;
    var $int1 = utils.int1Instance;
    var SCArray = $SC.Class(&quot;Array&quot;);

    spec.__num__ = function() {
      throw new Error(&quot;Wrong Type&quot;);
    };

    spec.__int__ = function() {
      return this.__num__()|0;
    };

    spec.__bool__ = function() {
      throw new Error(&quot;Wrong Type&quot;);
    };

    spec.__sym__ = function() {
      throw new Error(&quot;Wrong Type&quot;);
    };

    spec.__str__ = function() {
      return String(this);
    };

    // TODO: implements $new
    // TODO: implements $newCopyArgs

    spec.$newFrom = function() {
      return this._doesNotUnderstand(&quot;newFrom&quot;);
    };

    // TODO: implements dump
    // TODO: implements post
    // TODO: implements postln
    // TODO: implements postc
    // TODO: implements postcln
    // TODO: implements postcs
    // TODO: implements totalFree
    // TODO: implements largestFreeBlock
    // TODO: implements gcDumpGrey
    // TODO: implements gcDumpSet
    // TODO: implements gcInfo
    // TODO: implements gcSanity
    // TODO: implements canCallOS

    spec.size = utils.alwaysReturn$Integer_0;
    spec.indexedSize = utils.alwaysReturn$Integer_0;
    spec.flatSize = utils.alwaysReturn$Integer_1;

    spec.do = function($function) {
      $function = utils.defaultValue$Nil($function);

      sc.lang.iterator.execute(
        sc.lang.iterator.object$do(this),
        $function
      );

      return this;
    };

    spec.generate = function($function, $state) {
      $state = utils.defaultValue$Nil($state);

      this.do($function);

      return $state;
    };

    // already defined: class
    // already defined: isKindOf
    // already defined: isMemberOf

    spec.respondsTo = function($aSymbol) {
      $aSymbol = utils.defaultValue$Nil($aSymbol);
      return $SC.Boolean(typeof this[$aSymbol.__sym__()] === &quot;function&quot;);
    };

    // TODO: implements performMsg

    spec.perform = function($selector) {
      var selector, method;
      $selector = utils.defaultValue$Nil($selector);

      selector = $selector.__sym__();
      method = this[selector];

      if (method) {
        return method.apply(this, slice.call(arguments, 1));
      }

      throw new Error(&quot;Message &#039;&quot; + selector + &quot;&#039; not understood.&quot;);
    };

    spec.performList = function($selector, $arglist) {
      var selector, method;
      $selector = utils.defaultValue$Nil($selector);
      $arglist  = utils.defaultValue$Nil($arglist);

      selector = $selector.__sym__();
      method = this[selector];

      if (method) {
        return method.apply(this, $arglist.asArray()._);
      }

      throw new Error(&quot;Message &#039;&quot; + selector + &quot;&#039; not understood.&quot;);
    };

    spec.functionPerformList = utils.nop;

    // TODO: implements superPerform
    // TODO: implements superPerformList
    // TODO: implements tryPerform
    // TODO: implements multiChannelPerform
    // TODO: implements performWithEnvir
    // TODO: implements performKeyValuePairs

    var copy = function(obj) {
      var copied = obj;

      if (Array.isArray(obj)) {
        copied = obj.slice();
      } else if (obj &amp;&amp; obj.constructor === Object) {
        copied = {};
        Object.keys(obj).forEach(function(key) {
          copied[key] = obj[key];
        });
      }

      return copied;
    };

    spec.copy = function() {
      return this.shallowCopy();
    };

    // TODO: implements contentsCopy

    spec.shallowCopy = function() {
      var a = new this.__class._Spec();

      Object.keys(this).forEach(function(key) {
        a[key] = copy(this[key]);
      }, this);

      if (this._ === this) {
        a._ = a;
      }

      return a;
    };

    // TODO: implements copyImmutable
    // TODO: implements deepCopy

    spec.dup = function($n) {
      var $this = this;
      var $array, i, imax;

      $n = utils.defaultValue$Integer($n, 2);
      if (bool($n.isSequenceableCollection())) {
        return SCArray.fillND($n, $SC.Function(function() {
          return $this.copy();
        }));
      }

      $array = SCArray.new($n);
      for (i = 0, imax = $n.__int__(); i &lt; imax; ++i) {
        $array.add(this.copy());
      }

      return $array;
    };

    spec[&quot;!&quot;] = function($n) {
      return this.dup($n);
    };

    spec.poll = function() {
      return this.value();
    };

    spec.value = utils.nop;
    spec.valueArray = utils.nop;
    spec.valueEnvir = utils.nop;
    spec.valueArrayEnvir = utils.nop;

    spec[&quot;==&quot;] = function($obj) {
      return this [&quot;===&quot;] ($obj);
    };

    spec[&quot;!=&quot;] = function($obj) {
      return (this [&quot;==&quot;] ($obj)).not();
    };

    spec[&quot;===&quot;] = function($obj) {
      return $SC.Boolean(this === $obj);
    };

    spec[&quot;!==&quot;] = function($obj) {
      return $SC.Boolean(this !== $obj);
    };

    // TODO: implements equals
    // TODO: implements compareObject
    // TODO: implements instVarHash
    // TODO: implements basicHash
    // TODO: implements hash
    // TODO: implements identityHash

    spec[&quot;-&gt;&quot;] = function($obj) {
      return $SC.Class(&quot;Association&quot;).new(this, $obj);
    };

    spec.next = utils.nop;
    spec.reset = utils.nop;

    spec.first = function($inval) {
      $inval = utils.defaultValue$Nil($inval);

      this.reset();
      return this.next($inval);
    };

    spec.iter = function() {
      return $SC.Class(&quot;OneShotStream&quot;).new(this);
    };

    spec.stop = utils.nop;
    spec.free = utils.nop;
    spec.clear = utils.nop;
    spec.removedFromScheduler = utils.nop;
    spec.isPlaying = utils.alwaysReturn$False;

    spec.embedInStream = function() {
      return this.yield();
    };

    // TODO: implements cyc
    // TODO: implements fin
    // TODO: implements repeat
    // TODO: implements loop

    spec.asStream = utils.nop;

    // TODO: implements streamArg

    spec.eventAt = utils.alwaysReturn$Nil;

    spec.composeEvents = function($event) {
      $event = utils.defaultValue$Nil($event);
      return $event.copy();
    };

    spec.finishEvent = utils.nop;
    spec.atLimit = utils.alwaysReturn$False;
    spec.isRest = utils.alwaysReturn$False;
    spec.threadPlayer = utils.nop;
    spec.threadPlayer_ = utils.nop;
    spec[&quot;?&quot;] = utils.nop;
    spec[&quot;??&quot;] = utils.nop;

    spec[&quot;!?&quot;] = function($obj) {
      $obj = utils.defaultValue$Nil($obj);
      return $obj.value(this);
    };

    spec.isNil = utils.alwaysReturn$False;
    spec.notNil = utils.alwaysReturn$True;
    spec.isNumber = utils.alwaysReturn$False;
    spec.isInteger = utils.alwaysReturn$False;
    spec.isFloat = utils.alwaysReturn$False;
    spec.isSequenceableCollection = utils.alwaysReturn$False;
    spec.isCollection = utils.alwaysReturn$False;
    spec.isArray = utils.alwaysReturn$False;
    spec.isString = utils.alwaysReturn$False;
    spec.containsSeqColl = utils.alwaysReturn$False;
    spec.isValidUGenInput = utils.alwaysReturn$False;
    spec.isException = utils.alwaysReturn$False;
    spec.isFunction = utils.alwaysReturn$False;

    spec.matchItem = function($item) {
      $item = utils.defaultValue$Nil($item);
      return this [&quot;===&quot;] ($item);
    };

    spec.trueAt = utils.alwaysReturn$False;

    spec.falseAt = function($key) {
      $key = utils.defaultValue$Nil($key);
      return this.trueAt($key).not();
    };

    // TODO: implements pointsTo
    // TODO: implements mutable
    // TODO: implements frozen
    // TODO: implements halt
    // TODO: implements primitiveFailed
    // TODO: implements reportError
    // TODO: implements subclassResponsibility
    spec._subclassResponsibility = function(methodName) {
      throw new Error(&quot;RECEIVER &quot; + String(this) + &quot;: &quot; +
                      &quot;&#039;&quot; + methodName + &quot;&#039; should have been implemented by subclass&quot;);
    };

    // TODO: implements doesNotUnderstand
    spec._doesNotUnderstand = function(methodName) {
      throw new Error(&quot;RECEIVER &quot; + this.__str__() + &quot;: &quot; +
                      &quot;Message &#039;&quot; + methodName + &quot;&#039; not understood.&quot;);
    };

    // TODO: implements shouldNotImplement
    // TODO: implements outOfContextReturn
    // TODO: implements immutableError
    // TODO: implements deprecated
    // TODO: implements mustBeBoolean
    // TODO: implements notYetImplemented
    // TODO: implements dumpBackTrace
    // TODO: implements getBackTrace
    // TODO: implements throw

    spec.species = function() {
      return this.class();
    };

    spec.asCollection = function() {
      return $SC.Array([ this ]);
    };

    spec.asSymbol = function() {
      return this.asString().asSymbol();
    };

    spec.asString = function() {
      return $SC.String(String(this));
    };

    // TODO: implements asCompileString
    // TODO: implements cs
    // TODO: implements printClassNameOn
    // TODO: implements printOn
    // TODO: implements storeOn
    // TODO: implements storeParamsOn
    // TODO: implements simplifyStoreArgs
    // TODO: implements storeArgs
    // TODO: implements storeModifiersOn

    spec.as = function($aSimilarClass) {
      $aSimilarClass = utils.defaultValue$Nil($aSimilarClass);
      return $aSimilarClass.newFrom(this);
    };

    spec.dereference = utils.nop;

    spec.reference = function() {
      return $SC.Ref(this);
    };

    spec.asRef = function() {
      return $SC.Ref(this);
    };

    spec.asArray = function() {
      return this.asCollection().asArray();
    };

    spec.asSequenceableCollection = function() {
      return this.asArray();
    };

    spec.rank = utils.alwaysReturn$Integer_0;

    spec.deepCollect = function($depth, $function, $index, $rank) {
      $function = utils.defaultValue$Nil($function);
      return $function.value(this, $index, $rank);
    };

    spec.deepDo = function($depth, $function, $index, $rank) {
      $function = utils.defaultValue$Nil($function);
      $function.value(this, $index, $rank);
      return this;
    };

    spec.slice = utils.nop;
    spec.shape = utils.alwaysReturn$Nil;
    spec.unbubble = utils.nop;

    spec.bubble = function($depth, $levels) {
      var levels, a;
      $levels = utils.defaultValue$Integer($levels, 1);

      levels = $levels.__int__();
      if (levels &lt;= 1) {
        a = [ this ];
      } else {
        a = [
          this.bubble($depth, $SC.Integer(levels - 1))
        ];
      }

      return $SC.Array(a);
    };

    spec.obtain = function($index, $default) {
      $index   = utils.defaultValue$Nil($index);
      $default = utils.defaultValue$Nil($default);

      if ($index.__num__() === 0) {
        return this;
      } else {
        return $default;
      }
    };

    spec.instill = function($index, $item, $default) {
      $index = utils.defaultValue$Nil($index);
      $item  = utils.defaultValue$Nil($item);

      if ($index.__num__() === 0) {
        return $item;
      } else {
        return this.asArray().instill($index, $item, $default);
      }
    };

    spec.addFunc = fn(function($$functions) {
      return $SC.Class(&quot;FunctionList&quot;).new(this [&quot;++&quot;] ($$functions));
    }, &quot;*functions&quot;);

    spec.removeFunc = function($function) {
      if (this === $function) {
        return $nil;
      }
      return this;
    };

    spec.replaceFunc = function($find, $replace) {
      $replace = utils.defaultValue$Nil($replace);
      if (this === $find) {
        return $replace;
      }
      return this;
    };

    // TODO: implements addFuncTo
    // TODO: implements removeFuncFrom

    spec.while = function($body) {
      var $this = this;
      $body = utils.defaultValue$Nil($body);

      $SC.Function(function() {
        return $this.value();
      }).while($SC.Function(function() {
        return $body.value();
      }));

      return this;
    };

    spec.switch = function() {
      var args, i, imax;

      args = slice.call(arguments);
      for (i = 0, imax = args.length &gt;&gt; 1; i &lt; imax; i++) {
        if (bool(this [&quot;==&quot;] (args[i * 2]))) {
          return args[i * 2 + 1].value();
        }
      }

      if (args.length % 2 === 1) {
        return args[args.length - 1].value();
      }

      return $nil;
    };

    spec.yield = function() {
      // TODO: implements yield
    };

    // TODO: implements alwaysYield
    // TODO: implements yieldAndReset
    // TODO: implements idle
    // TODO: implements $initClass
    // TODO: implements dependants
    // TODO: implements changed
    // TODO: implements addDependant
    // TODO: implements removeDependant
    // TODO: implements release
    // TODO: implements releaseDependants
    // TODO: implements update
    // TODO: implements addUniqueMethod
    // TODO: implements removeUniqueMethods
    // TODO: implements removeUniqueMethod
    // TODO: implements inspect
    // TODO: implements inspectorClass
    // TODO: implements inspector
    // TODO: implements crash
    // TODO: implements stackDepth
    // TODO: implements dumpStack
    // TODO: implements dumpDetailedBackTrace
    // TODO: implements freeze

    spec[&quot;&amp;&quot;] = function($that) {
      return this.bitAnd($that);
    };

    spec[&quot;|&quot;] = function($that) {
      return this.bitOr($that);
    };

    spec[&quot;%&quot;] = function($that) {
      return this.mod($that);
    };

    spec[&quot;**&quot;] = function($that) {
      return this.pow($that);
    };

    spec[&quot;&lt;&lt;&quot;] = function($that) {
      return this.leftShift($that);
    };

    spec[&quot;&gt;&gt;&quot;] = function($that) {
      return this.rightShift($that);
    };

    spec[&quot;+&gt;&gt;&quot;] = function($that) {
      return this.unsignedRightShift($that);
    };

    spec[&quot;&lt;!&quot;] = function($that) {
      return this.firstArg($that);
    };

    spec.asInt = function() {
      return this.asInteger();
    };

    spec.blend = function($that, $blendFrac) {
      $that      = utils.defaultValue$Nil($that);
      $blendFrac = utils.defaultValue$Float($blendFrac, 0.5);
      return this [&quot;+&quot;] ($blendFrac [&quot;*&quot;] ($that [&quot;-&quot;] (this)));
    };

    spec.blendAt = function($index, $method) {
      var $iMin;
      $index  = utils.defaultValue$Nil($index);
      $method = utils.defaultValue$Symbol($method, &quot;clipAt&quot;);

      $iMin = $index.roundUp($int1).asInteger().__dec__();
      return this.perform($method, $iMin).blend(
        this.perform($method, $iMin.__inc__()),
        $index.absdif($iMin)
      );
    };

    spec.blendPut = function($index, $val, $method) {
      var $iMin, $ratio;
      $index  = utils.defaultValue$Nil($index);
      $val    = utils.defaultValue$Nil($val);
      $method = utils.defaultValue$Symbol($method, &quot;wrapPut&quot;);

      $iMin = $index.floor().asInteger();
      $ratio = $index.absdif($iMin);
      this.perform($method, $iMin, $val [&quot;*&quot;] ($int1 [&quot;-&quot;] ($ratio)));
      this.perform($method, $iMin.__inc__(), $val [&quot;*&quot;] ($ratio));

      return this;
    };

    spec.fuzzyEqual = function($that, $precision) {
      $that      = utils.defaultValue$Nil($that);
      $precision = utils.defaultValue$Float($precision, 1.0);

      return $SC.Float(0.0).max(
        $SC.Float(1.0) [&quot;-&quot;] (
          (this [&quot;-&quot;] ($that).abs()) [&quot;/&quot;] ($precision)
        )
      );
    };

    spec.isUGen = utils.alwaysReturn$False;
    spec.numChannels = utils.alwaysReturn$Integer_1;

    spec.pair = function($that) {
      $that = utils.defaultValue$Nil($that);
      return $SC.Array([ this, $that ]);
    };

    spec.pairs = function($that) {
      var $list;
      $that = utils.defaultValue$Nil($that);

      $list = $SC.Array();
      this.asArray().do($SC.Function(function($a) {
        $that.asArray().do($SC.Function(function($b) {
          $list = $list.add($a.asArray() [&quot;++&quot;] ($b));
        }));
      }));

      return $list;
    };

    spec.awake = function($beats) {
      return this.next($beats);
    };

    spec.beats_ = utils.nop;
    spec.clock_ = utils.nop;

    spec.performBinaryOpOnSomething = function($aSelector) {
      var aSelector;
      $aSelector = utils.defaultValue$Nil($aSelector);

      aSelector = $aSelector.__sym__();
      if (aSelector === &quot;==&quot;) {
        return utils.falseInstance;
      }
      if (aSelector === &quot;!=&quot;) {
        return utils.trueInstance;
      }

      throw new Error(&quot;binary operator &#039;&quot; + aSelector + &quot;&#039; failed.&quot;);
    };

    spec.performBinaryOpOnSimpleNumber = function($aSelector, $thig, $adverb) {
      return this.performBinaryOpOnSomething($aSelector, $thig, $adverb);
    };

    spec.performBinaryOpOnSignal  = spec.performBinaryOpOnSimpleNumber;
    spec.performBinaryOpOnComplex = spec.performBinaryOpOnSimpleNumber;
    spec.performBinaryOpOnSeqColl = spec.performBinaryOpOnSimpleNumber;
    spec.performBinaryOpOnUGen    = spec.performBinaryOpOnSimpleNumber;

    // TODO: implements writeDefFile

    spec.isInputUGen = utils.alwaysReturn$False;
    spec.isOutputUGen = utils.alwaysReturn$False;
    spec.isControlUGen = utils.alwaysReturn$False;
    spec.source = utils.nop;
    spec.asUGenInput = utils.nop;
    spec.asControlInput = utils.nop;

    spec.asAudioRateInput = function() {
      if (this.rate().__sym__() !== &quot;audio&quot;) {
        return $SC.Class(&quot;K2A&quot;).ar(this);
      }
      return this;
    };

    // TODO: implements slotSize
    // TODO: implements slotAt
    // TODO: implements slotPut
    // TODO: implements slotKey
    // TODO: implements slotIndex
    // TODO: implements slotsDo
    // TODO: implements slotValuesDo
    // TODO: implements getSlots
    // TODO: implements setSlots
    // TODO: implements instVarSize
    // TODO: implements instVarAt
    // TODO: implements instVarPut
    // TODO: implements writeArchive
    // TODO: implements $readArchive
    // TODO: implements asArchive
    // TODO: implements initFromArchive
    // TODO: implements archiveAsCompileString
    // TODO: implements archiveAsObject
    // TODO: implements checkCanArchive
    // TODO: implements writeTextArchive
    // TODO: implements $readTextArchive
    // TODO: implements asTextArchive
    // TODO: implements getContainedObjects
    // TODO: implements writeBinaryArchive
    // TODO: implements $readBinaryArchive
    // TODO: implements asBinaryArchive
    // TODO: implements genNext
    // TODO: implements genCurrent
    // TODO: implements $classRedirect
    // TODO: implements help
  });

})(sc);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
