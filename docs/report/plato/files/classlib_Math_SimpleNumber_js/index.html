<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - classlib/Math/SimpleNumber.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>classlib/Math/SimpleNumber.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">125.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">894</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">98.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.45</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">SCScript.install(function(sc) {
  &quot;use strict&quot;;

  require(&quot;./Number&quot;);

  var $ = sc.lang.$;
  var $nil  = $.nil;
  var $int0 = $.int0;
  var $int1 = $.int1;
  var random = sc.libs.random;
  var strlib = sc.libs.strlib;

  var SCArray = $(&quot;Array&quot;);
  var SCRoutine = $(&quot;Routine&quot;);

  function prOpSimpleNumber(selector, func) {
    return function($aNumber, $adverb) {
      var tag = $aNumber.__tag;

      switch (tag) {
      case sc.TAG_INT:
      case sc.TAG_FLOAT:
        return $.Boolean(func(this._, $aNumber._));
      }

      if ($aNumber.isSequenceableCollection().__bool__()) {
        return $aNumber.performBinaryOpOnSimpleNumber(
          $.Symbol(selector), this, $adverb
        );
      }

      return $.False();
    };
  }

  sc.lang.klass.refine(&quot;SimpleNumber&quot;, function(builder) {
    builder.addMethod(&quot;__newFrom__&quot;, $.Float);

    builder.addMethod(&quot;__bool__&quot;, function() {
      return this._ !== 0;
    });

    builder.addMethod(&quot;__dec__&quot;, function() {
      return this.__newFrom__(this._ - 1);
    });

    builder.addMethod(&quot;__inc__&quot;, function() {
      return this.__newFrom__(this._ + 1);
    });

    builder.addMethod(&quot;__int__&quot;, function() {
      if (!isFinite(this._)) {
        return this._;
      }
      return this._|0;
    });

    builder.addMethod(&quot;__num__&quot;, function() {
      return this._;
    });

    builder.addMethod(&quot;isValidUGenInput&quot;, function() {
      return $.Boolean(!isNaN(this._));
    });

    builder.addMethod(&quot;numChannels&quot;, function() {
      return $int1;
    });

    builder.addMethod(&quot;magnitude&quot;, function() {
      return this.abs();
    });

    builder.addMethod(&quot;angle&quot;, function() {
      return $.Float(this._ &gt;= 0 ? 0 : Math.PI);
    });

    builder.addMethod(&quot;neg&quot;, function() {
      return this.__newFrom__(-this._);
    });

    // bitNot: implemented by subclass

    builder.addMethod(&quot;abs&quot;, function() {
      return this.__newFrom__(Math.abs(this._));
    });

    builder.addMethod(&quot;ceil&quot;, function() {
      return this.__newFrom__(Math.ceil(this._));
    });

    builder.addMethod(&quot;floor&quot;, function() {
      return this.__newFrom__(Math.floor(this._));
    });

    builder.addMethod(&quot;frac&quot;, function() {
      var a = this._;

      if (a &lt; 0) {
        return this.__newFrom__(1 + (a - (a|0)));
      }
      return this.__newFrom__(a - (a|0));
    });

    builder.addMethod(&quot;sign&quot;, function() {
      var a = this._;
      return this.__newFrom__(
        a &gt; 0 ? 1 : a === 0 ? 0 : -1
      );
    });

    builder.addMethod(&quot;squared&quot;, function() {
      return this.__newFrom__(this._ * this._);
    });

    builder.addMethod(&quot;cubed&quot;, function() {
      return this.__newFrom__(this._ * this._ * this._);
    });

    builder.addMethod(&quot;sqrt&quot;, function() {
      return $.Float(Math.sqrt(this._));
    });

    builder.addMethod(&quot;exp&quot;, function() {
      return $.Float(Math.exp(this._));
    });

    builder.addMethod(&quot;reciprocal&quot;, function() {
      return $.Float(1 / this._);
    });

    builder.addMethod(&quot;midicps&quot;, function() {
      return $.Float(
        440 * Math.pow(2, (this._ - 69) * 1 / 12)
      );
    });

    builder.addMethod(&quot;cpsmidi&quot;, function() {
      return $.Float(
        Math.log(Math.abs(this._) * 1 / 440) * Math.LOG2E * 12 + 69
      );
    });

    builder.addMethod(&quot;midiratio&quot;, function() {
      return $.Float(
        Math.pow(2, this._ * 1 / 12)
      );
    });

    builder.addMethod(&quot;ratiomidi&quot;, function() {
      return $.Float(
        Math.log(Math.abs(this._)) * Math.LOG2E * 12
      );
    });

    builder.addMethod(&quot;ampdb&quot;, function() {
      return $.Float(
        Math.log(this._) * Math.LOG10E * 20
      );
    });

    builder.addMethod(&quot;dbamp&quot;, function() {
      return $.Float(
        Math.pow(10, this._ * 0.05)
      );
    });

    builder.addMethod(&quot;octcps&quot;, function() {
      return $.Float(
        440 * Math.pow(2, this._ - 4.75)
      );
    });

    builder.addMethod(&quot;cpsoct&quot;, function() {
      return $.Float(
        Math.log(Math.abs(this._) * 1 / 440) * Math.LOG2E + 4.75
      );
    });

    builder.addMethod(&quot;log&quot;, function() {
      return $.Float(Math.log(this._));
    });

    builder.addMethod(&quot;log2&quot;, function() {
      return $.Float(Math.log(Math.abs(this._)) * Math.LOG2E);
    });

    builder.addMethod(&quot;log10&quot;, function() {
      return $.Float(Math.log(this._) * Math.LOG10E);
    });

    builder.addMethod(&quot;sin&quot;, function() {
      return $.Float(Math.sin(this._));
    });

    builder.addMethod(&quot;cos&quot;, function() {
      return $.Float(Math.cos(this._));
    });

    builder.addMethod(&quot;tan&quot;, function() {
      return $.Float(Math.tan(this._));
    });

    builder.addMethod(&quot;asin&quot;, function() {
      return $.Float(Math.asin(this._));
    });

    builder.addMethod(&quot;acos&quot;, function() {
      return $.Float(Math.acos(this._));
    });

    builder.addMethod(&quot;atan&quot;, function() {
      return $.Float(Math.atan(this._));
    });

    function _sinh(a) {
      return (Math.pow(Math.E, a) - Math.pow(Math.E, -a)) * 0.5;
    }

    builder.addMethod(&quot;sinh&quot;, function() {
      return $.Float(_sinh(this._));
    });

    function _cosh(a) {
      return (Math.pow(Math.E, a) + Math.pow(Math.E, -a)) * 0.5;
    }

    builder.addMethod(&quot;cosh&quot;, function() {
      return $.Float(_cosh(this._));
    });

    builder.addMethod(&quot;tanh&quot;, function() {
      return $.Float(_sinh(this._) / _cosh(this._));
    });

    builder.addMethod(&quot;rand&quot;, function() {
      return this.__newFrom__(
        random.next() * this._
      );
    });

    builder.addMethod(&quot;rand2&quot;, function() {
      return this.__newFrom__(
        (random.next() * 2 - 1) * this._
      );
    });

    builder.addMethod(&quot;linrand&quot;, function() {
      return this.__newFrom__(
        Math.min(random.next(), random.next()) * this._
      );
    });

    builder.addMethod(&quot;bilinrand&quot;, function() {
      return this.__newFrom__(
        (random.next() - random.next()) * this._
      );
    });

    builder.addMethod(&quot;sum3rand&quot;, function() {
      return this.__newFrom__(
        (random.next() + random.next() + random.next() - 1.5) * 2 / 3 * this._
      );
    });

    builder.addMethod(&quot;distort&quot;, function() {
      return $.Float(
        this._ / (1 + Math.abs(this._))
      );
    });

    builder.addMethod(&quot;softclip&quot;, function() {
      var a = this._, abs = Math.abs(a);
      return $.Float(abs &lt;= 0.5 ? a : (abs - 0.25) / a);
    });

    builder.addMethod(&quot;coin&quot;, function() {
      return $.Boolean(random.next() &lt; this._);
    });

    builder.addMethod(&quot;isPositive&quot;, function() {
      return $.Boolean(this._ &gt;= 0);
    });

    builder.addMethod(&quot;isNegative&quot;, function() {
      return $.Boolean(this._ &lt; 0);
    });

    builder.addMethod(&quot;isStrictlyPositive&quot;, function() {
      return $.Boolean(this._ &gt; 0);
    });

    builder.addMethod(&quot;isNaN&quot;, function() {
      return $.Boolean(isNaN(this._));
    });

    builder.addMethod(&quot;asBoolean&quot;, function() {
      return $.Boolean(this._ &gt; 0);
    });

    builder.addMethod(&quot;booleanValue&quot;, function() {
      return $.Boolean(this._ &gt; 0);
    });

    builder.addMethod(&quot;binaryValue&quot;, function() {
      return this._ &gt; 0 ? $int1 : $int0;
    });

    builder.addMethod(&quot;rectWindow&quot;, function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $.Float(0);
      }
      return $.Float(1);
    });

    builder.addMethod(&quot;hanWindow&quot;, function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $.Float(0);
      }
      return $.Float(0.5 - 0.5 * Math.cos(a * 2 * Math.PI));
    });

    builder.addMethod(&quot;welWindow&quot;, function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $.Float(0);
      }
      return $.Float(Math.sin(a * Math.PI));
    });

    builder.addMethod(&quot;triWindow&quot;, function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $.Float(0);
      }
      if (a &lt; 0.5) {
        return $.Float(2 * a);
      }
      return $.Float(-2 * a + 2);
    });

    builder.addMethod(&quot;scurve&quot;, function() {
      var a = this._;
      if (a &lt;= 0) {
        return $.Float(0);
      }
      if (1 &lt;= a) {
        return $.Float(1);
      }
      return $.Float(a * a * (3 - 2 * a));
    });

    builder.addMethod(&quot;ramp&quot;, function() {
      var a = this._;
      if (a &lt;= 0) {
        return $.Float(0);
      }
      if (1 &lt;= a) {
        return $.Float(1);
      }
      return $.Float(a);
    });

    // +: implemented by subclass
    // -: implemented by subclass
    // *: implemented by subclass
    // /: implemented by subclass
    // mod: implemented by subclass
    // div: implemented by subclass
    // pow: implemented by subclass
    // min: implemented by subclass
    // max: implemented by subclass
    // bitAnd: implemented by subclass
    // bitOr : implemented by subclass
    // bitXor: implemented by subclass

    builder.addMethod(&quot;bitTest&quot;, function($bit) {
      return $.Boolean(
        this.bitAnd($int1.leftShift($bit)).__num__() !== 0
      );
    });

    // lcm     : implemented by subclass
    // gcd     : implemented by subclass
    // round   : implemented by subclass
    // roundUp : implemented by subclass
    // trunc   : implemented by subclass
    // atan2   : implemented by subclass
    // hypot   : implemented by subclass
    // hypotApx: implemented by subclass
    // leftShift         : implemented by subclass
    // rightShift        : implemented by subclass
    // unsignedRightShift: implemented by subclass
    // ring1 : implemented by subclass
    // ring2 : implemented by subclass
    // ring3 : implemented by subclass
    // ring4 : implemented by subclass
    // difsqr: implemented by subclass
    // sumsqr: implemented by subclass
    // sqrsum: implemented by subclass
    // sqrdif: implemented by subclass
    // absdif: implemented by subclass
    // thresh: implemented by subclass
    // amclip: implemented by subclass
    // clip2 : implemented by subclass
    // fold2 : implemented by subclass
    // wrap2 : implemented by subclass
    // excess: implemented by subclass
    // firstArg: implemented by subclass
    // rrand   : implemented by subclass
    // exprand : implemented by subclass

    builder.addMethod(&quot;==&quot;, function($aNumber) {
      return $.Boolean(this._ === $aNumber._);
    });

    builder.addMethod(&quot;!=&quot;, function($aNumber) {
      return $.Boolean(this._ !== $aNumber._);
    });

    builder.addMethod(&quot;&lt;&quot;, prOpSimpleNumber(&quot;&lt;&quot;, function(a, b) {
      return a &lt; b;
    }));

    builder.addMethod(&quot;&gt;&quot;, prOpSimpleNumber(&quot;&gt;&quot;, function(a, b) {
      return a &gt; b;
    }));

    builder.addMethod(&quot;&lt;=&quot;, prOpSimpleNumber(&quot;&lt;=&quot;, function(a, b) {
      return a &lt;= b;
    }));

    builder.addMethod(&quot;&gt;=&quot;, prOpSimpleNumber(&quot;&gt;=&quot;, function(a, b) {
      return a &gt;= b;
    }));

    builder.addMethod(&quot;equalWithPrecision&quot;, {
      args: &quot;that; precision=0.0001&quot;
    }, function($that, $precision) {
      return this.absdif($that) [&quot;&lt;&quot;] ($precision);
    });

    builder.addMethod(&quot;asInteger&quot;, function() {
      return $.Integer(this._);
    });

    builder.addMethod(&quot;asFloat&quot;, function() {
      return $.Float(this._);
    });

    // TODO: implements asComplex
    // TODO: implements asRect

    builder.addMethod(&quot;degrad&quot;, function() {
      return $.Float(this._ * Math.PI / 180);
    });

    builder.addMethod(&quot;raddeg&quot;, function() {
      return $.Float(this._ * 180 / Math.PI);
    });

    builder.addMethod(&quot;performBinaryOpOnSimpleNumber&quot;, function($aSelector) {
      throw new Error(strlib.format(&quot;binary operator &#039;#{0}&#039; failed&quot;, $aSelector.__sym__()));
    });

    // TODO: implements performBinaryOpOnComplex

    builder.addMethod(&quot;performBinaryOpOnSignal&quot;, function($aSelector) {
      throw new Error(strlib.format(&quot;binary operator &#039;#{0}&#039; failed&quot;, $aSelector.__sym__()));
    });

    builder.addMethod(&quot;nextPowerOfTwo&quot;, function() {
      return $.Float(
        Math.pow(2, Math.ceil(Math.log(this._) / Math.log(2)))
      );
    });

    builder.addMethod(&quot;nextPowerOf&quot;, {
      args: &quot;base&quot;
    }, function($base) {
      return $base.pow(
        (this.log() [&quot;/&quot;] ($base.$(&quot;log&quot;))).ceil()
      );
    });

    builder.addMethod(&quot;nextPowerOfThree&quot;, function() {
      return $.Float(
        Math.pow(3, Math.ceil(Math.log(this._) / Math.log(3)))
      );
    });

    builder.addMethod(&quot;previousPowerOf&quot;, {
      args: &quot;base&quot;
    }, function($base) {
      return $base.pow(
        (this.log() [&quot;/&quot;] ($base.$(&quot;log&quot;))).ceil().__dec__()
      );
    });

    builder.addMethod(&quot;quantize&quot;, {
      args: &quot;quantum=1.0; tolerance=0.05; strength=1.0&quot;
    }, function($quantum, $tolerance, $strength) {
      var $round, $diff;

      $round = this.round($quantum);
      $diff = $round [&quot;-&quot;] (this);

      if ($diff.abs() &lt; $tolerance) {
        return this [&quot;+&quot;] ($strength.$(&quot;*&quot;, [ $diff ]));
      }

      return this;
    });

    builder.addMethod(&quot;linlin&quot;, {
      args: &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;
    }, function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // (this-inMin)/(inMax-inMin) * (outMax-outMin) + outMin;
        $res = ((this [&quot;-&quot;] ($inMin)) [&quot;/&quot;] ($inMax [&quot;-&quot;] ($inMin))
              [&quot;*&quot;] ($outMax [&quot;-&quot;] ($outMin)) [&quot;+&quot;] ($outMin));
      }

      return $res;
    });

    builder.addMethod(&quot;linexp&quot;, {
      args: &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;
    }, function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // Math.pow(outMax/outMin, (this-inMin)/(inMax-inMin)) * outMin;
        $res = $outMax [&quot;/&quot;] ($outMin).pow(
          (this [&quot;-&quot;] ($inMin)) [&quot;/&quot;] ($inMax [&quot;-&quot;] ($inMin))
        ) [&quot;*&quot;] ($outMin);
      }

      return $res;
    });

    builder.addMethod(&quot;explin&quot;, {
      args: &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;
    }, function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // (((Math.log(this/inMin)) / (Math.log(inMax/inMin))) * (outMax-outMin)) + outMin;
        $res = ((this [&quot;/&quot;] ($inMin).log() [&quot;/&quot;] ($inMax [&quot;/&quot;] ($inMin).log())
                 [&quot;*&quot;] ($outMax [&quot;-&quot;] ($outMin))) [&quot;+&quot;] ($outMin));
      }

      return $res;
    });

    builder.addMethod(&quot;expexp&quot;, {
      args: &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;
    }, function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // Math.pow(outMax/outMin, Math.log(this/inMin) / Math.log(inMax/inMin)) * outMin;
        $res = $outMax [&quot;/&quot;] ($outMin).pow(
          this [&quot;/&quot;] ($inMin).log() [&quot;/&quot;] ($inMax [&quot;/&quot;] ($inMin).log())
        ) [&quot;*&quot;] ($outMin);
      }

      return $res;
    });

    builder.addMethod(&quot;lincurve&quot;, {
      args: &quot;inMin=0; inMax=1; outMin=0; outMax=1; curve=-4; clip=\\minmax&quot;
    }, function($inMin, $inMax, $outMin, $outMax, $curve, $clip) {
      var $res = null, $grow, $a, $b, $scaled;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (Math.abs($curve.__num__()) &lt; 0.001) {
          $res = this.linlin($inMin, $inMax, $outMin, $outMax);
        } else {
          $grow = $curve.exp();
          $a = $outMax [&quot;-&quot;] ($outMin) [&quot;/&quot;] ($.Float(1.0) [&quot;-&quot;] ($grow));
          $b = $outMin [&quot;+&quot;] ($a);
          $scaled = (this [&quot;-&quot;] ($inMin)) [&quot;/&quot;] ($inMax [&quot;-&quot;] ($inMin));

          $res = $b [&quot;-&quot;] ($a [&quot;*&quot;] ($grow.pow($scaled)));
        }
      }

      return $res;
    });

    builder.addMethod(&quot;curvelin&quot;, {
      args: &quot;inMin=0; inMax=1; outMin=0; outMax=1; curve=-4; clip=\\minmax&quot;
    },function($inMin, $inMax, $outMin, $outMax, $curve, $clip) {
      var $res = null, $grow, $a, $b;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (Math.abs($curve.__num__()) &lt; 0.001) {
          $res = this.linlin($inMin, $inMax, $outMin, $outMax);
        } else {
          $grow = $curve.exp();
          $a = $inMax [&quot;-&quot;] ($inMin) [&quot;/&quot;] ($.Float(1.0) [&quot;-&quot;] ($grow));
          $b = $inMin [&quot;+&quot;] ($a);

          $res = ((($b [&quot;-&quot;] (this)) [&quot;/&quot;] ($a)).log()
                  [&quot;*&quot;] ($outMax [&quot;-&quot;] ($outMin)) [&quot;/&quot;] ($curve) [&quot;+&quot;] ($outMin));
        }
      }

      return $res;
    });

    builder.addMethod(&quot;bilin&quot;, {
      args: &quot;inCenter; inMin; inMax; outCenter; outMin; outMax; clip=\\minmax&quot;
    }, function($inCenter, $inMin, $inMax, $outCenter, $outMin, $outMax, $clip) {
      var $res = null;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (this &gt;= $inCenter) {
          $res = this.linlin($inCenter, $inMax, $outCenter, $outMax, $.Symbol(&quot;none&quot;));
        } else {
          $res = this.linlin($inMin, $inCenter, $outMin, $outCenter, $.Symbol(&quot;none&quot;));
        }
      }

      return $res;
    });

    builder.addMethod(&quot;biexp&quot;, {
      args: &quot;inCenter; inMin; inMax; outCenter; outMin; outMax; clip=\\minmax&quot;
    }, function($inCenter, $inMin, $inMax, $outCenter, $outMin, $outMax, $clip) {
      var $res = null;

      $res = getClippedValue(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (this &gt;= $inCenter) {
          $res = this.explin($inCenter, $inMax, $outCenter, $outMax, $.Symbol(&quot;none&quot;));
        } else {
          $res = this.explin($inMin, $inCenter, $outMin, $outCenter, $.Symbol(&quot;none&quot;));
        }
      }

      return $res;
    });

    builder.addMethod(&quot;moddif&quot;, {
      args: &quot;aNumber=0.0; mod=1.0&quot;
    }, function($aNumber, $mod) {
      var $diff, $modhalf;

      $diff = this.absdif($aNumber) [&quot;%&quot;] ($mod);
      $modhalf = $mod.$(&quot;*&quot;, [ $.Float(0.5) ]);

      return $modhalf.$(&quot;-&quot;, [ $diff.absdif($modhalf) ]);
    });

    builder.addMethod(&quot;lcurve&quot;, {
      args: &quot;a=1.0; m=0.0; n=1.0; tau=1.0&quot;
    }, function($a, $m, $n, $tau) {
      var $rTau, $x;

      $x = this.neg();

      if ($tau.__num__() === 1.0) {
        // a * (m * exp(x) + 1) / (n * exp(x) + 1)
        return $a.$(&quot;*&quot;, [
          $m.$(&quot;*&quot;, [ $x.exp() ]).__inc__()
        ]).$(&quot;/&quot;, [
          $n.$(&quot;*&quot;, [ $x.exp() ]).__inc__()
        ]);
      } else {
        $rTau = $tau.reciprocal();
        return $a.$(&quot;*&quot;, [
          $m.$(&quot;*&quot;, [ $x.exp() ]) [&quot;*&quot;] ($rTau).__inc__()
        ]).$(&quot;/&quot;, [
          $n.$(&quot;*&quot;, [ $x.exp() ]) [&quot;*&quot;] ($rTau).__inc__()
        ]);
      }
    });

    builder.addMethod(&quot;gauss&quot;, {
      args: &quot;standardDeviation&quot;
    }, function($standardDeviation) {
      // ^((((-2*log(1.0.rand)).sqrt * sin(2pi.rand)) * standardDeviation) + this)
      return ($.Float(-2.0) [&quot;*&quot;] ($.Float(1.0).rand().log()).sqrt() [&quot;*&quot;] (
        $.Float(2 * Math.PI).rand().sin()
      ) [&quot;*&quot;] ($standardDeviation)) [&quot;+&quot;] (this);
    });

    builder.addMethod(&quot;gaussCurve&quot;, {
      args: &quot;a=1.0; b=0.0; c=1.0&quot;
    }, function($a, $b, $c) {
      // ^a * (exp(squared(this - b) / (-2.0 * squared(c))))
      return $a.$(&quot;*&quot;, [ ((
        (this [&quot;-&quot;] ($b).squared()) [&quot;/&quot;] ($.Float(-2.0) [&quot;*&quot;] ($c.$(&quot;squared&quot;)))
      ).exp()) ]);
    });

    // TODO: implements asPoint
    // TODO: implements asWarp

    builder.addMethod(&quot;wait&quot;, function() {
      return this.yield();
    });

    // TODO: implements waitUntil
    // TODO: implements sleep
    // TODO: implements printOn
    // TODO: implements storeOn

    builder.addMethod(&quot;rate&quot;, function() {
      return $.Symbol(&quot;scalar&quot;);
    });

    builder.addMethod(&quot;asAudioRateInput&quot;, function() {
      if (this._ === 0) {
        return $(&quot;Silent&quot;).ar();
      }
      return $(&quot;DC&quot;).ar(this);
    });

    builder.addMethod(&quot;madd&quot;, {
      args: &quot;mul; add&quot;
    }, function($mul, $add) {
      return (this [&quot;*&quot;] ($mul)) [&quot;+&quot;] ($add);
    });

    builder.addMethod(&quot;lag&quot;);
    builder.addMethod(&quot;lag2&quot;);
    builder.addMethod(&quot;lag3&quot;);
    builder.addMethod(&quot;lagud&quot;);
    builder.addMethod(&quot;lag2ud&quot;);
    builder.addMethod(&quot;lag3ud&quot;);
    builder.addMethod(&quot;varlag&quot;);
    builder.addMethod(&quot;slew&quot;);

    // TODO: implements writeInputSpec

    builder.addMethod(&quot;series&quot;, {
      args: &quot;second; last&quot;
    }, function($second, $last) {
      var $step;
      var last, step, size;

      if ($second === $nil) {
        if (this.__num__() &lt; $last.__num__()) {
          $second = this.__inc__();
        } else {
          $second = this.__dec__();
        }
      }
      $step = $second [&quot;-&quot;] (this);

      last = $last.__num__();
      step = $step.__num__();
      size = (Math.floor((last - this._) / step + 0.001)|0) + 1;

      return SCArray.series($.Integer(size), this, $step);
    });

    builder.addMethod(&quot;seriesIter&quot;, {
      args: &quot;second; last&quot;
    }, function($second, $last) {
      var first, second, last, step;
      var $newFrom = this.__newFrom__;

      first = this.__num__();
      if ($second === $nil) {
        last = ($last !== $nil) ? $last.__num__() : Infinity;
        step = first &lt; last ? 1 : -1;
      } else {
        second = $second.__num__();
        last = ($last !== $nil) ? $last.__num__() : (
          $second &lt; first ? -Infinity : Infinity
        );
        step = second - first;
      }
      return SCRoutine.new($.Function(function() {
        var val, $cond;
        $cond = $.Func(step &lt; 0 ? function() {
          return $.Boolean(val &gt;= last);
        } : function() {
          return $.Boolean(val &lt;= last);
        });
        return [ function() {
          val = first;
          return $cond.while($.Func(function() {
            $newFrom(val).yield();
            val += step;
            return $nil;
          }));
        } ];
      }));
    });

    builder.addMethod(&quot;degreeToKey&quot;, {
      args: &quot;scale; stepsPerOctave=12&quot;
    }, function($scale, $stepsPerOctave) {
      var $scaleDegree, $accidental;
      $scaleDegree = this.round($int1).asInteger();
      $accidental  = (this [&quot;-&quot;] ($scaleDegree)) [&quot;*&quot;] ($.Float(10.0));
      return $scale.performDegreeToKey($scaleDegree, $stepsPerOctave, $accidental);
    });

    builder.addMethod(&quot;keyToDegree&quot;, {
      args: &quot;scale; stepsPerOctave=12&quot;
    }, function($scale, $stepsPerOctave) {
      return $scale.performKeyToDegree(this, $stepsPerOctave);
    });

    builder.addMethod(&quot;nearestInList&quot;, {
      args: &quot;list&quot;
    }, function($list) {
      return $list.performNearestInList(this);
    });

    builder.addMethod(&quot;nearestInScale&quot;, {
      args: &quot;scale; stepsPerOctave=12&quot;
    }, function($scale, $stepsPerOctave) {
      return $scale.performNearestInScale(this, $stepsPerOctave);
    });

    builder.addMethod(&quot;partition&quot;, {
      args: &quot;parts=2; min=1&quot;
    }, function($parts, $min) {
      var $n = this [&quot;-&quot;] ($min.__dec__() [&quot;*&quot;] ($parts));
      return $int1.series(null, $n.__dec__()).scramble().keep($parts.__dec__())
        .sort().add($n).differentiate() [&quot;+&quot;] ($min.__dec__());
    });

    builder.addMethod(&quot;nextTimeOnGrid&quot;, {
      args: &quot;clock&quot;
    }, function($clock) {
      return $clock.nextTimeOnGrid(this, $int0);
    });

    builder.addMethod(&quot;playAndDelta&quot;);

    builder.addMethod(&quot;asQuant&quot;, function() {
      return $(&quot;Quant&quot;).new(this);
    });

    // TODO: implements asTimeString
    // TODO: implements asFraction
    // TODO: implements asBufWithValues
    // TODO: implements schedBundleArrayOnClock

    builder.addMethod(&quot;shallowCopy&quot;);
  });

  function getClippedValue($this, $inMin, $inMax, $outMin, $outMax, $clip) {
    switch ($clip.__sym__()) {
    case &quot;minmax&quot;:
      if ($this &lt;= $inMin) {
        return $outMin;
      }
      if ($this &gt;= $inMax) {
        return $outMax;
      }
      break;
    case &quot;min&quot;:
      if ($this &lt;= $inMin) {
        return $outMin;
      }
      break;
    case &quot;max&quot;:
      if ($this &gt;= $inMax) {
        return $outMax;
      }
      break;
    }

    return null;
  }
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
