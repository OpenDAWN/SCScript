<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lang/classlib/Math/SimpleNumber.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lang/classlib/Math/SimpleNumber.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">126.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">777</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.44</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(sc) {
  &quot;use strict&quot;;

  require(&quot;./Number&quot;);

  var fn   = sc.lang.fn;
  var $SC  = sc.lang.$SC;
  var rand = sc.libs.random;

  function prOpSimpleNumber(selector, func) {
    return function($aNumber, $adverb) {
      var tag = $aNumber.__tag;

      switch (tag) {
      case sc.C.TAG_INT:
      case sc.C.TAG_FLOAT:
        return $SC.Boolean(func(this._, $aNumber._));
      }

      if ($aNumber.isSequenceableCollection().valueOf()) {
        return $aNumber.performBinaryOpOnSimpleNumber(
          $SC.Symbol(selector), this, $adverb
        );
      }

      return $SC.False();
    };
  }

  sc.lang.klass.refine(&quot;SimpleNumber&quot;, function(spec, utils) {
    var $nil   = utils.$nil;
    var $int_0 = utils.$int_0;
    var $int_1 = utils.$int_1;
    var SCArray = $SC(&quot;Array&quot;);

    spec.__newFrom__ = $SC.Float;

    spec.__bool__ = function() {
      return this._ !== 0;
    };

    spec.__dec__ = function() {
      return this.__newFrom__(this._ - 1);
    };

    spec.__inc__ = function() {
      return this.__newFrom__(this._ + 1);
    };

    spec.__int__ = function() {
      if (!isFinite(this._)) {
        return this._;
      }
      return this._|0;
    };

    spec.__num__ = function() {
      return this._;
    };

    spec.isValidUGenInput = function() {
      return $SC.Boolean(!isNaN(this._));
    };

    spec.numChannels = utils.alwaysReturn$int_1;

    spec.magnitude = function() {
      return this.abs();
    };

    spec.angle = function() {
      return $SC.Float(this._ &gt;= 0 ? 0 : Math.PI);
    };

    spec.neg = function() {
      return this.__newFrom__(-this._);
    };

    // bitNot: implemented by subclass

    spec.abs = function() {
      return this.__newFrom__(Math.abs(this._));
    };

    spec.ceil = function() {
      return this.__newFrom__(Math.ceil(this._));
    };

    spec.floor = function() {
      return this.__newFrom__(Math.floor(this._));
    };

    spec.frac = function() {
      var a = this._;

      if (a &lt; 0) {
        return this.__newFrom__(1 + (a - (a|0)));
      }
      return this.__newFrom__(a - (a|0));
    };

    spec.sign = function() {
      var a = this._;
      return this.__newFrom__(
        a &gt; 0 ? 1 : a === 0 ? 0 : -1
      );
    };

    spec.squared = function() {
      return this.__newFrom__(this._ * this._);
    };

    spec.cubed = function() {
      return this.__newFrom__(this._ * this._ * this._);
    };

    spec.sqrt = function() {
      return $SC.Float(Math.sqrt(this._));
    };

    spec.exp = function() {
      return $SC.Float(Math.exp(this._));
    };

    spec.reciprocal = function() {
      return $SC.Float(1 / this._);
    };

    spec.midicps = function() {
      return $SC.Float(
        440 * Math.pow(2, (this._ - 69) * 1/12)
      );
    };

    spec.cpsmidi = function() {
      return $SC.Float(
        Math.log(Math.abs(this._) * 1/440) * Math.LOG2E * 12 + 69
      );
    };

    spec.midiratio = function() {
      return $SC.Float(
        Math.pow(2, this._ * 1/12)
      );
    };

    spec.ratiomidi = function() {
      return $SC.Float(
        Math.log(Math.abs(this._)) * Math.LOG2E * 12
      );
    };

    spec.ampdb = function() {
      return $SC.Float(
        Math.log(this._) * Math.LOG10E * 20
      );
    };

    spec.dbamp = function() {
      return $SC.Float(
        Math.pow(10, this._ * 0.05)
      );
    };

    spec.octcps = function() {
      return $SC.Float(
        440 * Math.pow(2, this._ - 4.75)
      );
    };

    spec.cpsoct = function() {
      return $SC.Float(
        Math.log(Math.abs(this._) * 1/440) * Math.LOG2E + 4.75
      );
    };

    spec.log = function() {
      return $SC.Float(Math.log(this._));
    };

    spec.log2 = function() {
      return $SC.Float(Math.log(Math.abs(this._)) * Math.LOG2E);
    };

    spec.log10 = function() {
      return $SC.Float(Math.log(this._) * Math.LOG10E);
    };

    spec.sin = function() {
      return $SC.Float(Math.sin(this._));
    };

    spec.cos = function() {
      return $SC.Float(Math.cos(this._));
    };

    spec.tan = function() {
      return $SC.Float(Math.tan(this._));
    };

    spec.asin = function() {
      return $SC.Float(Math.asin(this._));
    };

    spec.acos = function() {
      return $SC.Float(Math.acos(this._));
    };

    spec.atan = function() {
      return $SC.Float(Math.atan(this._));
    };

    function _sinh(a) {
      return (Math.pow(Math.E, a) - Math.pow(Math.E, -a)) * 0.5;
    }

    spec.sinh = function() {
      return $SC.Float(_sinh(this._));
    };

    function _cosh(a) {
      return (Math.pow(Math.E, a) + Math.pow(Math.E, -a)) * 0.5;
    }

    spec.cosh = function() {
      return $SC.Float(_cosh(this._));
    };

    spec.tanh = function() {
      return $SC.Float(_sinh(this._) / _cosh(this._));
    };

    spec.rand = function() {
      return this.__newFrom__(
        rand.next() * this._
      );
    };

    spec.rand2 = function() {
      return this.__newFrom__(
        (rand.next() * 2 - 1) * this._
      );
    };

    spec.linrand = function() {
      return this.__newFrom__(
        Math.min(rand.next(), rand.next()) * this._
      );
    };

    spec.bilinrand = function() {
      return this.__newFrom__(
        (rand.next() - rand.next()) * this._
      );
    };

    spec.sum3rand = function() {
      return this.__newFrom__(
        (rand.next() + rand.next() + rand.next() - 1.5) * 2/3 * this._
      );
    };

    spec.distort = function() {
      return $SC.Float(
        this._ / (1 + Math.abs(this._))
      );
    };

    spec.softclip = function() {
      var a = this._, abs_a = Math.abs(a);
      return $SC.Float(abs_a &lt;= 0.5 ? a : (abs_a - 0.25) / a);
    };

    spec.coin = function() {
      return $SC.Boolean(rand.next() &lt; this._);
    };

    spec.isPositive = function() {
      return $SC.Boolean(this._ &gt;= 0);
    };

    spec.isNegative = function() {
      return $SC.Boolean(this._ &lt; 0);
    };

    spec.isStrictlyPositive = function() {
      return $SC.Boolean(this._ &gt; 0);
    };

    spec.isNaN = function() {
      return $SC.Boolean(isNaN(this._));
    };

    spec.asBoolean = function() {
      return $SC.Boolean(this._ &gt; 0);
    };

    spec.booleanValue = function() {
      return $SC.Boolean(this._ &gt; 0);
    };

    spec.binaryValue = function() {
      return this._ &gt; 0 ? $int_1 : $int_0;
    };

    spec.rectWindow = function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $SC.Float(0);
      }
      return $SC.Float(1);
    };

    spec.hanWindow = function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $SC.Float(0);
      }
      return $SC.Float(0.5 - 0.5 * Math.cos(a * 2 * Math.PI));
    };

    spec.welWindow = function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $SC.Float(0);
      }
      return $SC.Float(Math.sin(a * Math.PI));
    };

    spec.triWindow = function() {
      var a = this._;
      if (a &lt; 0 || 1 &lt; a) {
        return $SC.Float(0);
      }
      if (a &lt; 0.5) {
        return $SC.Float(2 * a);
      }
      return $SC.Float(-2 * a + 2);
    };

    spec.scurve = function() {
      var a = this._;
      if (a &lt;= 0) {
        return $SC.Float(0);
      }
      if (1 &lt;= a) {
        return $SC.Float(1);
      }
      return $SC.Float(a * a * (3 - 2 * a));
    };

    spec.ramp = function() {
      var a = this._;
      if (a &lt;= 0) {
        return $SC.Float(0);
      }
      if (1 &lt;= a) {
        return $SC.Float(1);
      }
      return $SC.Float(a);
    };

    // +: implemented by subclass
    // -: implemented by subclass
    // *: implemented by subclass
    // /: implemented by subclass
    // mod: implemented by subclass
    // div: implemented by subclass
    // pow: implemented by subclass
    // min: implemented by subclass
    // max: implemented by subclass
    // bitAnd: implemented by subclass
    // bitOr : implemented by subclass
    // bitXor: implemented by subclass

    spec.bitTest = function($bit) {
      return $SC.Boolean(
        this.bitAnd($int_1.leftShift($bit)).valueOf() !== 0
      );
    };

    // lcm     : implemented by subclass
    // gcd     : implemented by subclass
    // round   : implemented by subclass
    // roundUp : implemented by subclass
    // trunc   : implemented by subclass
    // atan2   : implemented by subclass
    // hypot   : implemented by subclass
    // hypotApx: implemented by subclass
    // leftShift         : implemented by subclass
    // rightShift        : implemented by subclass
    // unsignedRightShift: implemented by subclass
    // ring1 : implemented by subclass
    // ring2 : implemented by subclass
    // ring3 : implemented by subclass
    // ring4 : implemented by subclass
    // difsqr: implemented by subclass
    // sumsqr: implemented by subclass
    // sqrsum: implemented by subclass
    // sqrdif: implemented by subclass
    // absdif: implemented by subclass
    // thresh: implemented by subclass
    // amclip: implemented by subclass
    // clip2 : implemented by subclass
    // fold2 : implemented by subclass
    // wrap2 : implemented by subclass
    // excess: implemented by subclass
    // firstArg: implemented by subclass
    // rrand   : implemented by subclass
    // exprand : implemented by subclass

    spec[&quot;==&quot;] = function($aNumber) {
      return $SC.Boolean(this._ === $aNumber._);
    };

    spec[&quot;!=&quot;] = function($aNumber) {
      return $SC.Boolean(this._ !== $aNumber._);
    };

    spec[&quot;&lt;&quot;] = prOpSimpleNumber(&quot;&lt;&quot;, function(a, b) {
      return a &lt; b;
    });
    spec[&quot;&gt;&quot;] = prOpSimpleNumber(&quot;&gt;&quot;, function(a, b) {
      return a &gt; b;
    });
    spec[&quot;&lt;=&quot;] = prOpSimpleNumber(&quot;&lt;=&quot;, function(a, b) {
      return a &lt;= b;
    });
    spec[&quot;&gt;=&quot;] = prOpSimpleNumber(&quot;&gt;=&quot;, function(a, b) {
      return a &gt;= b;
    });

    spec.equalWithPrecision = fn(function($that, $precision) {
      return this.absdif($that) [&quot;&lt;&quot;] ($precision);
    }, &quot;that; precision=0.0001&quot;);

    // TODO: implements hash

    spec.asInteger = function() {
      return $SC.Integer(this._);
    };

    spec.asFloat = function() {
      return $SC.Float(this._);
    };

    // TODO: implements asComplex
    // TODO: implements asRect

    spec.degrad = function() {
      return $SC.Float(this._ * Math.PI / 180);
    };

    spec.raddeg = function() {
      return $SC.Float(this._ * 180 / Math.PI);
    };

    // TODO: implements performBinaryOpOnSimpleNumber
    // TODO: implements performBinaryOpOnComplex
    // TODO: implements performBinaryOpOnSignal

    spec.nextPowerOfTwo = function() {
      return $SC.Float(
        Math.pow(2, Math.ceil(Math.log(this._) / Math.log(2)))
      );
    };

    spec.nextPowerOf = fn(function($base) {
      return $base.pow(
        (this.log() [&quot;/&quot;] ($base.log())).ceil()
      );
    }, &quot;base&quot;);

    spec.nextPowerOfThree = function() {
      return $SC.Float(
        Math.pow(3, Math.ceil(Math.log(this._) / Math.log(3)))
      );
    };

    spec.previousPowerOf = fn(function($base) {
      return $base.pow(
        (this.log() [&quot;/&quot;] ($base.log())).ceil().__dec__()
      );
    }, &quot;base&quot;);

    spec.quantize = fn(function($quantum, $tolerance, $strength) {
      var $round, $diff;

      $round = this.round($quantum);
      $diff = $round [&quot;-&quot;] (this);

      if ($diff.abs() &lt; $tolerance) {
        return this [&quot;+&quot;] ($strength [&quot;*&quot;] ($diff));
      }

      return this;
    }, &quot;quantum=1.0; tolerance=0.05; strength=1.0&quot;);

    spec.linlin = fn(function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // (this-inMin)/(inMax-inMin) * (outMax-outMin) + outMin;
        $res = ((this [&quot;-&quot;] ($inMin)) [&quot;/&quot;] ($inMax [&quot;-&quot;] ($inMin))
              [&quot;*&quot;] ($outMax [&quot;-&quot;] ($outMin)) [&quot;+&quot;] ($outMin));
      }

      return $res;
    }, &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;);

    spec.linexp = fn(function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // Math.pow(outMax/outMin, (this-inMin)/(inMax-inMin)) * outMin;
        $res = $outMax [&quot;/&quot;] ($outMin).pow(
          (this [&quot;-&quot;] ($inMin)) [&quot;/&quot;] ($inMax [&quot;-&quot;] ($inMin))
        ) [&quot;*&quot;] ($outMin);
      }

      return $res;
    }, &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;);

    spec.explin = fn(function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // (((Math.log(this/inMin)) / (Math.log(inMax/inMin))) * (outMax-outMin)) + outMin;
        $res = ((this [&quot;/&quot;] ($inMin).log() [&quot;/&quot;] ($inMax [&quot;/&quot;] ($inMin).log())
                 [&quot;*&quot;] ($outMax [&quot;-&quot;] ($outMin))) [&quot;+&quot;] ($outMin));
      }

      return $res;
    }, &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;);

    spec.expexp = fn(function($inMin, $inMax, $outMin, $outMax, $clip) {
      var $res = null;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        // Math.pow(outMax/outMin, Math.log(this/inMin) / Math.log(inMax/inMin)) * outMin;
        $res = $outMax [&quot;/&quot;] ($outMin).pow(
          this [&quot;/&quot;] ($inMin).log() [&quot;/&quot;] ($inMax [&quot;/&quot;] ($inMin).log())
        ) [&quot;*&quot;] ($outMin);
      }

      return $res;
    }, &quot;inMin; inMax; outMin; outMax; clip=\\minmax&quot;);

    spec.lincurve = fn(function($inMin, $inMax, $outMin, $outMax, $curve, $clip) {
      var $res = null, $grow, $a, $b, $scaled;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (Math.abs($curve.valueOf()) &lt; 0.001) {
          $res = this.linlin($inMin, $inMax, $outMin, $outMax);
        } else {
          $grow = $curve.exp();
          $a = $outMax [&quot;-&quot;] ($outMin) [&quot;/&quot;] ($SC.Float(1.0) [&quot;-&quot;] ($grow));
          $b = $outMin [&quot;+&quot;] ($a);
          $scaled = (this [&quot;-&quot;] ($inMin)) [&quot;/&quot;] ($inMax [&quot;-&quot;] ($inMin));

          $res = $b [&quot;-&quot;] ($a [&quot;*&quot;] ($grow.pow($scaled)));
        }
      }

      return $res;
    }, &quot;inMin=0; inMax=1; outMin=0; outMax=1; curve=-4; clip=\\minmax&quot;);

    spec.curvelin = fn(function($inMin, $inMax, $outMin, $outMax, $curve, $clip) {
      var $res = null, $grow, $a, $b;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (Math.abs($curve.valueOf()) &lt; 0.001) {
          $res = this.linlin($inMin, $inMax, $outMin, $outMax);
        } else {
          $grow = $curve.exp();
          $a = $inMax [&quot;-&quot;] ($inMin) [&quot;/&quot;] ($SC.Float(1.0) [&quot;-&quot;] ($grow));
          $b = $inMin [&quot;+&quot;] ($a);

          $res = ((($b [&quot;-&quot;] (this)) [&quot;/&quot;] ($a)).log()
                  [&quot;*&quot;] ($outMax [&quot;-&quot;] ($outMin)) [&quot;/&quot;] ($curve) [&quot;+&quot;] ($outMin));
        }
      }

      return $res;
    }, &quot;inMin=0; inMax=1; outMin=0; outMax=1; curve=-4; clip=\\minmax&quot;);

    spec.bilin = fn(function($inCenter, $inMin, $inMax, $outCenter, $outMin, $outMax, $clip) {
      var $res = null;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (this &gt;= $inCenter) {
          $res = this.linlin($inCenter, $inMax, $outCenter, $outMax, $SC.Symbol(&quot;none&quot;));
        } else {
          $res = this.linlin($inMin, $inCenter, $outMin, $outCenter, $SC.Symbol(&quot;none&quot;));
        }
      }

      return $res;
    }, &quot;inCenter; inMin; inMax; outCenter; outMin; outMax; clip=\\minmax&quot;);

    spec.biexp = fn(function($inCenter, $inMin, $inMax, $outCenter, $outMin, $outMax, $clip) {
      var $res = null;

      $res = clip_for_map(this, $inMin, $inMax, $outMin, $outMax, $clip);

      if ($res === null) {
        if (this &gt;= $inCenter) {
          $res = this.explin($inCenter, $inMax, $outCenter, $outMax, $SC.Symbol(&quot;none&quot;));
        } else {
          $res = this.explin($inMin, $inCenter, $outMin, $outCenter, $SC.Symbol(&quot;none&quot;));
        }
      }

      return $res;
    }, &quot;inCenter; inMin; inMax; outCenter; outMin; outMax; clip=\\minmax&quot;);

    spec.moddif = fn(function($aNumber, $mod) {
      var $diff, $modhalf;

      $diff = this.absdif($aNumber) [&quot;%&quot;] ($mod);
      $modhalf = $mod [&quot;*&quot;] ($SC.Float(0.5));

      return $modhalf [&quot;-&quot;] ($diff.absdif($modhalf));
    }, &quot;aNumber=0.0; mod=1.0&quot;);

    spec.lcurve = fn(function($a, $m, $n, $tau) {
      var $rTau, $x;

      $x = this.neg();

      if ($tau.__num__() === 1.0) {
        // a * (m * exp(x) + 1) / (n * exp(x) + 1)
        return $a [&quot;*&quot;] (
          $m [&quot;*&quot;] ($x.exp()).__inc__()
        ) [&quot;/&quot;] (
          $n [&quot;*&quot;] ($x.exp()).__inc__()
        );
      } else {
        $rTau = $tau.reciprocal();
        return $a [&quot;*&quot;] (
          $m [&quot;*&quot;] ($x.exp()) [&quot;*&quot;] ($rTau).__inc__()
        ) [&quot;/&quot;] (
          $n [&quot;*&quot;] ($x.exp()) [&quot;*&quot;] ($rTau).__inc__()
        );
      }
    }, &quot;a=1.0; m=0.0; n=1.0; tau=1.0&quot;);

    spec.gauss = fn(function($standardDeviation) {
      // ^((((-2*log(1.0.rand)).sqrt * sin(2pi.rand)) * standardDeviation) + this)
      return ($SC.Float(-2.0) [&quot;*&quot;] ($SC.Float(1.0).rand().log()).sqrt() [&quot;*&quot;] (
        $SC.Float(2 * Math.PI).rand().sin()
      ) [&quot;*&quot;] ($standardDeviation)) [&quot;+&quot;] (this);
    }, &quot;standardDeviation&quot;);

    spec.gaussCurve = fn(function($a, $b, $c) {
      // ^a * (exp(squared(this - b) / (-2.0 * squared(c))))
      return $a [&quot;*&quot;] ((
        (this [&quot;-&quot;] ($b).squared()) [&quot;/&quot;] ($SC.Float(-2.0) [&quot;*&quot;] ($c.squared()))
      ).exp());
    }, &quot;a=1.0; b=0.0; c=1.0&quot;);

    // TODO: implements asPoint
    // TODO: implements asWarp

    spec.wait = function() {
      return this.yield();
    };

    // TODO: implements waitUntil
    // TODO: implements sleep
    // TODO: implements printOn
    // TODO: implements storeOn

    spec.rate = function() {
      return $SC.Symbol(&quot;scalar&quot;);
    };

    spec.asAudioRateInput = function() {
      if (this._ === 0) {
        return $SC(&quot;Silent&quot;).ar();
      }
      return $SC(&quot;DC&quot;).ar(this);
    };

    spec.madd = fn(function($mul, $add) {
      return (this [&quot;*&quot;] ($mul)) [&quot;+&quot;] ($add);
    }, &quot;mul; add&quot;);

    spec.lag = utils.nop;
    spec.lag2 = utils.nop;
    spec.lag3 = utils.nop;
    spec.lagud = utils.nop;
    spec.lag2ud = utils.nop;
    spec.lag3ud = utils.nop;
    spec.varlag = utils.nop;
    spec.slew = utils.nop;

    // TODO: implements writeInputSpec

    spec.series = fn(function($second, $last) {
      var $step;
      var last, step, size;

      if ($second === $nil) {
        if (this.valueOf() &lt; $last.valueOf()) {
          $second = this.__inc__();
        } else {
          $second = this.__dec__();
        }
      }
      $step = $second [&quot;-&quot;] (this);

      last = $last.__num__();
      step = $step.__num__();
      size = (Math.floor((last - this._) / step + 0.001)|0) + 1;

      return SCArray.series($SC.Integer(size), this, $step);
    }, &quot;second; last&quot;);

    // TODO: implements seriesIter
    // TODO: implements degreeToKey
    // TODO: implements keyToDegree
    // TODO: implements nearestInList
    // TODO: implements nearestInScale
    // TODO: implements partition
    // TODO: implements nextTimeOnGrid
    // TODO: implements playAndDelta
    // TODO: implements asQuant
    // TODO: implements asTimeString
    // TODO: implements asFraction
    // TODO: implements asBufWithValues
    // TODO: implements schedBundleArrayOnClock

    spec.shallowCopy = utils.nop;
  });

  function clip_for_map($this, $inMin, $inMax, $outMin, $outMax, $clip) {

    switch ($clip.__sym__()) {
    case &quot;minmax&quot;:
      if ($this &lt;= $inMin) {
        return $outMin;
      }
      if ($this &gt;= $inMax) {
        return $outMax;
      }
      break;
    case &quot;min&quot;:
      if ($this &lt;= $inMin) {
        return $outMin;
      }
      break;
    case &quot;max&quot;:
      if ($this &gt;= $inMax) {
        return $outMax;
      }
      break;
    }

    return null;
  }

})(sc);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
